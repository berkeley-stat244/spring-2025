---
title: "Notes Set 1: Introduction"
author: "Chris Paciorek"
date: "2025-01-14"
format:
  pdf:
    documentclass: article
    margin-left: 30mm
    margin-right: 30mm
    toc: true
  html:
    theme: cosmo
    css: ../assets/styles.css
    toc: true
    code-copy: true
    code-block-background: true
jupyter: julia-1.10
ipynb-shell-interactivity: all
---

## Introduction

This document is the first of a set of notes giving an overview of key syntax, tools, and concepts for using Julia. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.

Given that, the document heavily relies on demos, with interpretation in some cases left to the reader.

This document covers basic syntax, basic types, data structures, and functions.

## Variables and types

### Basic types

Let's start by defining some variables and seeing what their types are.

```{julia}
typeof(2)
x = 2.0
typeof(x)
s = "hello"
typeof(s)
typeof(s[1])
typeof('\n')
## Unicode characters
'h'
'i'
'\n'
'θ'

y = (3, 7.5)
typeof(y)
```

As we'll be discussing more, knowing what type a variable is (particularly for large objects such as large arrays) is important for thinking about memory use, what methods work with what types of variables, and when variables need to be cast/coerced to a different type.

We can enter LaTeX characters/formatting by typing in LaTeX syntax (using a "\") and then TAB.

```{julia}
θ = 3.57  # \theta TAB

#=
Note the use of a comment
in the initial line.

And this here is a multi-line comment.
=#

x₁ = 7  # x\_1 TAB
```

### A bit about strings

```{julia}
#| eval: false
x = 'hello'

x = "hello"
x[1] = "a"

```


### Casting/coercing between types

```{julia}
string(32)
parse(Float64, "32.5")
```

Some languages (such as R) will often cast between types behind the scenes. With Julia, one is often
more deliberate about types as we'll see.

## Functions and operators

### Operators (and not just for math/booleans)

```{julia}
#| error: true
value = 7;
value *= 3;
value
Value

x = 3
tmp = 7x   # Unlike any other language I know!

s * " there"

s^4
```



### Getting help on functions

Type `?` to get into help mode, then the name of the function you want help on.

To see all the functions/operators available in base Julia, type "Base." and hit tab.


### Function definitions

```{julia}
function plus3(x=0)
  return 3+x
end

plus3(5)
```

### Vectorized use

To use a function (or operator) in a vectorized way, we (with exceptions) need to use the dot notation.

```{julia}
#| error: true
y = [5.3, 2.5]

y + 3
y .+ 3

plus3(y)
plus3.(y)

## Apparently no general "recycling"/broadcasting.
x = [2.1, 3.1, 5.3, 7.9]
x .+ [0., 100.]

```

### Shorthand function definitions

These can be handy, but as a beginner with Julia, I find them a bit hard to read.

```{julia}
plus3(x=1) = 3+x

plus3 = (x=1) -> 3+x

# An anonymous function (useful for maps, functional programming).
((x) -> 3+x)(7)
```

### Positional and keyword arguments

Positional arguments (which are matched based on the order they are given) are specified before keyword arguments.  

```{julia}
#| error: true
function foo(x, y; w, z)
  return x - y + z * w
end

foo(3, 5, 7, 9)
foo(3, 5, z = 9, w = 7)
foo(3, 5; z = 9, w = 7)
foo(y = 5, x = 3, w = 7, z = 9)
```

function foo2(; x, y, w, z)
  return x - y + z * w
end

foo2(y = 5, x = 3, z = 9, w = 7)
```

Arguments can have defaults:

```{julia}
function foo(x=0, y=0; add=true)
  if add
    return x + y
  else
    return x*y
  end
end
```

:::{.callout-tip title="Exercise"}
Try out various argument orders and giving or not giving names or values to the arguments and try to figure out the syntax rules of how Julia behaves. Think about how they are similar/different to your primary language and whether you like the syntax rules.
:::

Keyword arguments are generally used for controlling function behavior rather than as core inputs. They are not involved in multiple dispatch (more later).

## Some additional topics

### Basic variable types (and comparisons)

```{julia}
x = 3
y = 3.0
x == y
x ≠ y
x > y
x > y || x <= y

isa(x, Int)
y isa Int
y isa Number

'a' ∈ "banana"  # \in TAB
'a' ∉ "banana"  # \notin TAB

aString = "a"
'a' == aString
'a' == aString[1]
```

### Conditional (if-else) statements

```{julia}
if x < y
    println("x is less than y")
elseif x > y
    println("x is greater than y")
else
    println("x and y are equal")
end
```

### Printing and string interpolation

We can use variables in print statements in various ways.

```{julia}
person = "Alice"

person = "Alice";

"Hello, $(person) with name of length $(length(person))."

println("Hello, ", person, " with name of length ", length(person), ".")
println("Hello, $(person) with name of length $(length(person)).")
println("Hello, " * person * " with name of length " * string(length(person)) * ".")
```

## Arrays and subsetting

### Sequences (and slicing)

```{julia}
some_text = "This is the Greek θ"
some_text[1]
some_text[19]
some_text[1:4]
some_text[17:end]
```


```{julia}
y = [1.1, 2.1, 3.2, 4.3, 5.7]
println(y)               # Original vector
println(y[1:3])          # First 3 elements
println(y[1:2:4])        # All odd-numbered elements
println(y[end:-1:2])     # From end back to second element in reverse
println(y[4:3])          # Empty subset
z = y[:]                 # All elements (copy (not alias) of original vector)
println(y[[4,2,4,3,3]])  # Slice by index
y[[true,false,true,false,true]]   # Slice by boolean array
```

:::{.callout-tip title="Exercise"}
Experiment more with slicing/indexing to make sure you get it, and what errors can occur. (As an example what happens if you index beyond the extent of the object?
:::

Note that the discussion of `fruits[len]` in Section 7 of Think Julia is incorrect.

### Arrays (i.e., lists)

x = ["spam", 2.0, 5, Missing, [10, 20], NaN]
length(x)

typeof(x)
y = [10, 20, 30, 40]
typeof(y)
x[1] = 3.3
x[4] = 2.7
typeof(x)   # Mutable, but type doesn't change.
```

:::{.callout-note title="Math with arrays"}

For computational efficiency, we'd want the array to contain elements all of the same type.

Note that languages like R and Python distinguish types intended for math (e.g., numpy arrays, R matrices) from more general types (e.g., lists). This is not the case for Julia, where the key thing is the type(s) involved.
:::

### Multi-dimensional arrays

```{julia}
A = [1 2 3; 4 5 6; 7 8 9]
A
A[2,2]
A[2,:]

size(A)
size(A, 2)

## Defined column-wise:
A = [1:4  5:8  ones(Int64,4)]
```

### Arrays vs. vectors

```{julia}
ones(5)
ones(5, 1)
ones(1, 5)
ones(5, 5)

## Outer product:
ones(5, 1) * ones(1, 5)
ones(5, 1) .* ones(1, 5)
```


### A bit of linear algebra

We do linear algebra directly on the core Array type.

```{julia}
A = [1 2 3; 4 1 6; 7 8 1]
A * A
```

Much more in a few weeks.

### More on vectorization

```{julia}
x = ["spam", 2.0, 5, [10, 20]]
length(x)
length.(x)
map(length, x)

x = [2.1, 3.1, 5.3, 7.9]
x .+ 10

x + x

x .> 5.0
x .== 3.1
```

### Reduction

```{julia}
A = rand(4, 5)
sum(A)
sum(A, dims = 1)  # 2D array result
sum(A, dims = 1)[:]  # 1D array result

sum(A, dims = 2)
```

### List comprehension (comprehension syntax)

Similar to Python. 

```{julia}
ysq = [ w^2 for w in y ]
xsqu = [ x^2 for x = 1:5 ]

xsqu_even = [ x^2 for x = 1:5 if iseven(x)]

norm2 = [ x^2 + y^2 for x = 1:5, y = 1:5 ]
```

A nice terse shorthand but can be hard to read.

(Some people love it and some people hate it.)


## Dictionaries and tuples

### Dictionaries

Key-value pairs like Python dictionaries (and somewhat like named R lists).

```{julia}
#| error: true
x = Dict("test" => 3, "tmp" => [2.1, 3.5], 7 => "weird")
x["tmp"][2]
x[7]
x["newkey"] = 'a'
keys(x)

x["hello"]
get(x, "hello", 0)
```

Note that the keys don't have to be strings! This could be good for caching/memoizing/lookup:

```{julia}
x = Dict(["foo", "bar"] => 3, "tmp" => [2.1, 3.5], 7 => "weird")
x[["foo", "bar"]]
ind = 7
x[ind]
```

What do you think will happen here?

```{julia}
#| eval: false
ind = Int32(7)  # What do you expect?
x[ind]
ind = 7.0       # What do you expect?
x[ind]
```

### Tuples

Tuples are are similar to 1-dimensional arrays but they are immutable (they can't be modified)
and can have named elements.

```{julia}
#| error: true
x = (3, 5, "hello")
x[2]
x[2] = 7

x = 3
y = 9
y,x = x,y

# Named tuple:
x = (a=3, b=5, other="hello")
x.b
```

What do you think will happen here?

```{julia}
#| eval: false
x = (a=3, b=5, other="hello", b="foo")
x.b
```

Tuples come in handy for providing flexibility in function inputs and outputs, as seen next.

### Tuples and functions

Here we create a function that can take an arbitrary number of inputs.

```{julia}
function flexsum(args...)
   println("The first value is $(args[1]).")
   return sum(args)
end

flexsum(5, 7, 9)
```

Here's how to call a function that takes multiple inputs, but pass as a tuple:

```{julia}
function mydiv(x, y)
   return x / y
end

vals = [3,5]
mydiv(vals...)
```

We use tuples to have a function return multiple values.

```{julia}
function test()
  return 3, 5, [3,7]
end

test()
```

## Loops

```{julia}
numThrows = 1000;
in_circle = 0;

# Run Monte Carlo simulation
for _ in 1:numThrows
  # Generate random points on 2x2 square.
  xPos = rand() * 2 - 1.0  # Equivalent to random.uniform(-1.0, 1.0)
  yPos = rand() * 2 - 1.0

  # Is point inside unit circle?
  if sqrt(xPos^2 + yPos^2) <= 1.0  # Equivalent to math.hypot()
    in_circle += 1
  end
end

# Estimate PI
pi_estimate = 4 * in_circle / numThrows
```

Variables defined in the loop are local variables accessible only in the scope of the loop (more on this soon). This avoids clutter in the global scope.

```{julia}
#| error: true
xPos
```

We can iterate over elements of an object like this:

```{julia}
for i in eachindex(x)
  println(i)
end
```

## String processing and regular expressions

```{julia}
x = "The cat in the hat."
replace(x, "at"=>"")

x = "We found 999 red balloons."
replace(x, r"[0-9]+"=>"some")  # Regular expression.

'a' ∈ "banana"
```

```{julia}
x = "We found 99 red balloons."
m = match(r"[0-9]+ ([a-z]+)", x)
m.match
m.captures
m.offset
```
