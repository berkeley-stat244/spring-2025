[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Scheduling information",
    "section": "",
    "text": "UNDER CONSTRUCTION - ignore the date below for now.",
    "crumbs": [
      "Schedule"
    ]
  },
  {
    "objectID": "schedule.html#schedule",
    "href": "schedule.html#schedule",
    "title": "Scheduling information",
    "section": "",
    "text": "UNDER CONSTRUCTION - ignore the date below for now.",
    "crumbs": [
      "Schedule"
    ]
  },
  {
    "objectID": "schedule.html#schedule-1",
    "href": "schedule.html#schedule-1",
    "title": "Scheduling information",
    "section": "Schedule",
    "text": "Schedule\n\n\n\n   Week 2\n\n   \n   \n   \n   \n   \n   \n\n        \n\n           \n           \n           \n           \n           \n           Jan 28:\n           \n           \n              Problem_Set 1 Problem Set 1\n           \n           \n                \n           \n                \n           \n        \n   \n   \n   \n  \n\n\nNo matching items",
    "crumbs": [
      "Schedule"
    ]
  },
  {
    "objectID": "notes/notes2.html",
    "href": "notes/notes2.html",
    "title": "Notes 2: Memory and scope",
    "section": "",
    "text": "This document is the second of a set of notes, this document focusing on memory, storage of objects, and variable scope. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader.",
    "crumbs": [
      "Course Notes",
      "Notes 2: Memory and scope"
    ]
  },
  {
    "objectID": "notes/notes2.html#introduction",
    "href": "notes/notes2.html#introduction",
    "title": "Notes 2: Memory and scope",
    "section": "",
    "text": "This document is the second of a set of notes, this document focusing on memory, storage of objects, and variable scope. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader.",
    "crumbs": [
      "Course Notes",
      "Notes 2: Memory and scope"
    ]
  },
  {
    "objectID": "notes/notes2.html#memory-use",
    "href": "notes/notes2.html#memory-use",
    "title": "Notes 2: Memory and scope",
    "section": "Memory use",
    "text": "Memory use\n\nMutable objects\nLet’s see if Julia behaves as we would expect if we try to change objects in different ways.\n\nx = \"hello\"\nx[1] = \"a\" \n\nx = [3.1, 2.1]\nx[2] = 5.5\n\nconst tmpVar = [3.1, 2.1]\ntmpVar[2] = 5.5 \ntmpVar = \"foo\"   \n\nx = (3, 5, \"hello\")\nx[2] = 7  \n\nconst tmpVarTuple = (3, 5, \"hello\")\ntmpVarTuple = (5, 9)\n\nBe careful as const objects cannot be deleted or reassigned.\nOne nice aspect of this is that you can define a variable without fear that it will be used in some other way.\n\n\nModifying objects in place\nUse of &lt;function_name&gt;!() indicates the function operates on the inputs in place and modifies arguments (non-black box execution).\n\nt = ['a', 'b', 'c'];\npush!(t, 'd')\n\n4-element Vector{Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n\npop!(t)\n\n'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n\n\n\npush(t, 'e')\n\nUndefVarError: `push` not defined\n\nx = Dict(\"test\" =&gt; 3, \"tmp\" =&gt; [2.1, 3.5], 7 =&gt; \"weird\")\n\nDict{Any, Any} with 3 entries:\n  7      =&gt; \"weird\"\n  \"test\" =&gt; 3\n  \"tmp\"  =&gt; [2.1, 3.5]\n\npop!(x, \"tmp\");\npush!(x, 'b' =&gt; 3);\nx\n\nDict{Any, Any} with 3 entries:\n  7      =&gt; \"weird\"\n  \"test\" =&gt; 3\n  'b'    =&gt; 3\n\n\n\n\n\n\n\n\nExercise\n\n\n\nSee if you can create a function that does not have “!” at the end of the name that modifies an input argument.\n\n\n\n\nMemory use and copying\nWe can use === to see if objects are identical. For mutable objects this involves looking at whether the data is stored at the same place in memory.\n\na = \"banana\"\n\n\"banana\"\n\nb = \"banana\"\n\n\"banana\"\n\na === b\n\ntrue\n\na ≡ b\n\ntrue\n\n\na = [1, 2, 3];\nb = a;\nc = [1, 2, 3];\n\na === b\n\ntrue\n\na === c\n\nfalse\n\na == c\n\ntrue\n\n\na = [1, 2, [4,7]]\n\n3-element Vector{Any}:\n 1\n 2\n  [4, 7]\n\nc = [1, 2, [3]]\n\n3-element Vector{Any}:\n 1\n 2\n  [3]\n\n\nc[3] = a[3]\n\n2-element Vector{Int64}:\n 4\n 7\n\n\na === c\n\nfalse\n\na[3] === c[3]\n\ntrue\n\n\n\n\nAliasing\nThis avoids copying but can be dangerous. The behavior is like Python, but not like R.\n\na = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\nb = a\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\na[1] = 99\n\n99\n\nb\n\n3-element Vector{Int64}:\n 99\n  2\n  3\n\n\n\n\nUsing copies rather than aliases\n\nx = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\ny = x[:]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\npop!(x)\n\n3\n\ny\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nIt would be useful to know if there’s a way to make a copy of an array without having to know its dimension.\n\n\n\n\nObjects in memory\nIf we want to see the memory address of an object, you can use pointer_from_objref.\nIn which of these cases do you expect that the same object in memory is referenced?\n\na = [1, 2, 3]\nb = a\nc = [1, 2, 3]\npointer_from_objref(a)\npointer_from_objref(b)\npointer_from_objref(c)\n\ntmp = [4,7]\na = [1, 2, tmp, [4,7]]\npointer_from_objref(tmp)\npointer_from_objref(a[3])\npointer_from_objref(a[4])\n\nWhat happens with pointer_from_objref on immutable objects?\n\nx = (3,5)\npointer_from_objref(x)\n\nERROR: pointer_from_objref cannot be used on immutable objects\n\ny = \"hello\"\n\n\"hello\"\n\npointer_from_objref(y)\n\nPtr{Nothing} @0x00007f2682837a78\n\n\nThere’s a bit more info in the help for pointer_from_objref.\n\n\nPass by reference\nJulia uses pass by reference. If you pass a mutable object into a function and modify it, that affects the state of the object outside of the function; no local copy of the object is made. This is efficient in terms of copying and memory use, but it does not following functional programming principles.\n\nfunction array_modifier(x)\n    push!(x, 12)\n    return Nothing\nend\n\narray_modifier (generic function with 1 method)\n\n\ny = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\narray_modifier(y)\n\nNothing\n\ny\n\n4-element Vector{Int64}:\n  1\n  2\n  3\n 12\n\n\nWe should instead define the function as array_modifier! to be consistent with Julia’s syntax.\n\nfunction array_modifier!(x)\n    push!(x, 12)\n    return Nothing\nend\n\narray_modifier! (generic function with 1 method)\n\n\ny = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\narray_modifier!(y)\n\nNothing\n\ny\n\n4-element Vector{Int64}:\n  1\n  2\n  3\n 12\n\n\n\n\n\n\n\n\nUsing tuples to prevent side effects\n\n\n\nIf we use a tuple as input to a function, we don’t have to worry about the input being modified; any attempt at modification will throw an error.\n\n\n\n\nExample\nConsider this function, modified from a Python function that was modified from an R function that I was looking at with a student who wanted to reduce the memory use of his code.\n\nfunction fastcount(xvar, yvar)\n    naline = isnan.(xvar)\n    naline[isnan.(yvar)] .= 1\n    localx = xvar[:]\n    localy = yvar[:]\n    localx[naline] .= 0\n    localy[naline] .= 0\n    useline = .!naline\n    # Rest of code...\nend\n\nfastcount (generic function with 1 method)\n\n\nusing Random, Distributions\nn = 20;\nx = rand(Normal(), n);\ny = rand(Normal(), n);\nx[[3, 5]] .= NaN;\ny[[1, 7]] .= NaN;\nfastcount(x, y);\n\n\n\n\n\n\n\nExercise\n\n\n\nDetermine all the places where additional memory is allocated (including for any temporary arrays).\n\n\n\n\nArrays and pointers\nIf we have an array made of numbers all of the same type, the values can be stored contiguously in memory.\n\nn = Int(1e7);\nx = randn(Float32, n);\nsizeof(x)\n\n40000000\n\ntypeof(x)\n\nVector{Float32} (alias for Array{Float32, 1})\n\n\nWhat about an array where the elements are not all the same type?\n\n\n\n\n\n\nExercise\n\n\n\nWhat does the following code indicate about how arrays of heterogeneous elements are stored? And how many bytes is a pointer?\n\n\n\nx = [1.3, 2.5, 7.4, \"hello\"]\n\n4-element Vector{Any}:\n 1.3\n 2.5\n 7.4\n  \"hello\"\n\nsizeof(x)\n\n32\n\ntypeof(x)\n\nVector{Any} (alias for Array{Any, 1})\n\ndevs = randn(n);\nx[1] = devs;\nsizeof(x)\n\n32\n\n\n\npointer_from_objref(devs)\n\nPtr{Nothing} @0x00007f267f0cc010\n\npointer_from_objref(x[1])\n\nPtr{Nothing} @0x00007f267f0cc010\n\ndevs[1]\n\n0.13862731447680088\n\nx[1][1]\n\n0.13862731447680088\n\ndevs[1] = 3.0\n\n3.0\n\nx[1][1]\n\n3.0\n\n\n\n\n\n\n\n\nExercise\n\n\n\nCheck your understanding by creating an array of matrices where each of the individual matrices are just pointers to the same underlying matrix. Modify the underlying matrix. Modify one of the matrices. See what happens.\nSide note: suppose x is a matrix. What’s the difference between [x, x], [x x], and [x; x]?",
    "crumbs": [
      "Course Notes",
      "Notes 2: Memory and scope"
    ]
  },
  {
    "objectID": "notes/notes2.html#scope",
    "href": "notes/notes2.html#scope",
    "title": "Notes 2: Memory and scope",
    "section": "Scope",
    "text": "Scope\n\nLexical scoping\nJulia uses lexical scoping, which means that lookup of non-local variables occurs in the scope in which a function is defined, not the scope from which it was called. This means that code is easier to reason about (where the behavior of a function doesn’t depend on where it is called from) and is modular.\n\n\n\n\n\n\nExercise: Lexical scoping\n\n\n\nExperiment with the following cases and make sure you understand how the lookup / scoping is working. Predict the result before running the code.\n\n\nCase 1: Will the code print 3 or 7?\n\n# Case 1\nx = 3\nfunction f2()\n    print(x)\nend\n\nfunction f()\n    x = 7\n    f2()\nend\n\nf() # what will happen?\n\nCase 2: Will the code print 3, 7, or 100?\n\nx = 3\nfunction f2()\n    print(x)\nend\n\nfunction f()\n    x = 7\n    f2()\nend\n\nx = 100\nf() # what will happen?\n\nCase 3: Will the code print 3, 7, or 100?\n\nx = 3\nfunction f()\n    function f2()\n        print(x)\n    end\n    x = 7\n    f2()\nend\n\nx = 100\nf() # what will happen?\n\nCase 4: Will the code print 3 or 100 or produce an error?\n\nx = 3\nfunction f()\n    function f2()\n        print(x)\n    end\n    f2()\nend\n\nx = 100\nf() # what will happen?\n\n\n\nClosures\nHere’s a somewhat tricky scoping example:\n\ny = 100\nfunction fun_constructor()\n    y = 10\n    function g(x)\n        return x + y\n    end\n    return g\nend\n\n## fun_constructor() creates functions\nmyfun = fun_constructor()\nmyfun(3)\n\n\n\n\n\n\n\nExercise: Lexical scoping\n\n\n\nTry to understand what is going on with fun_constructor. What do you expect myfun(3) to return? Where is myfun defined?\nExtra: modify fun_constructor in such a way that you can determine if g can modify y in the enclosing scope.\n\n\nThe above is an example of a closure, a useful concept in functional programming that provides functionality similar to object-oriented programming. y is “bound” up/captured in the enclosing scope of g/myfun.",
    "crumbs": [
      "Course Notes",
      "Notes 2: Memory and scope"
    ]
  },
  {
    "objectID": "notes/notes2.html#global-and-local-scopes",
    "href": "notes/notes2.html#global-and-local-scopes",
    "title": "Notes 2: Memory and scope",
    "section": "Global and local scopes",
    "text": "Global and local scopes\n\nGlobal and local variables\nWe can access global variables from within functions via Julia’s scoping rules, as seen previously.\nTo modify global variables, we need to use global.\n\nx = 100\n\n100\n\n\nfunction test()\n  global x\n  println(x)\n  x = 3;\n  return nothing\nend\n\ntest (generic function with 1 method)\n\n\ntest()\n\n100\n\nprint(x)\n\n3\n\n\nThis is like Python. Also note the difference in behavior compared to being able to modify the captured variable in the closure without any explicit syntax.\nInterestingly, this doesn’t work to be able to access both a local and global variable of the same name. Nor does it work in Python, but it does work in R. Clearly there is some processing that determines assignment operations before the code in the function body is evaluated.\n\ny = 100\n\nfunction test()\n  println(y)\n  y = 3;\n  return nothing\nend\n\ntest()\n\nERROR: UndefVarError: `y` not defined\nNote that use of global in Section 8 (Looping and Counting) of Think Julia seems incorrect/unnecessary.\n\n\nModules\nYou can isolate code from your working context using module.\n\nx = 0;\n\nmodule testmod\n  x = 99;\nend\n\ntestmod.x\n\n99\n\nx\n\n0\nEach module has its own global scope. And each code block has its own local scope (as we saw with the for loop in Notes 1).\n\nfor i in 1:3\n  tmp = i*7\nend\n\nprint(tmp)\n\nERROR: UndefVarError: `tmp` not defined\n\nprint(i)\n\nERROR: UndefVarError: `i` not defined\nScoping gets rather more complicated.\nThe use of using adds variables from a package/module to the current scope.\n\nA = rand(3, 3);\neigvals(A)\n\nERROR: UndefVarError: `eigvals` not defined\n\nA = rand(3, 3);\nusing LinearAlgebra\neigvals(A)\n\n3-element Vector{Float64}:\n -0.37070516708703843\n -0.35038525717381275\n  1.5056321634365166\n\n\n\n\nLet blocks\nYou can also use let to create a new scope:\n\nx = 0\n\n0\n\n\nlet x = 5\n  print(x)\nend\n\n5\n\n\nprint(x)\n\n0",
    "crumbs": [
      "Course Notes",
      "Notes 2: Memory and scope"
    ]
  },
  {
    "objectID": "notes/notes4.html",
    "href": "notes/notes4.html",
    "title": "Notes 4: Managing Julia",
    "section": "",
    "text": "This document is the fourth of a set of notes, this document focusing on managing and interacting with Julia, including working with and creating Julia packages. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader. Note that for many of the package/project-related demos, I haven’t run the code as part of the document rendering as the output is large and it affects that state of Julia in ways that are not helpful.\n\n\n\n\n\n\nWarning\n\n\n\nThere’s a lot of configuration details in the section on using packages. It’s not critical to absorb it all at this point, but it’s here for when you need it. In part I went into detail as I was trying to understand the details myself.",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#introduction",
    "href": "notes/notes4.html#introduction",
    "title": "Notes 4: Managing Julia",
    "section": "",
    "text": "This document is the fourth of a set of notes, this document focusing on managing and interacting with Julia, including working with and creating Julia packages. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader. Note that for many of the package/project-related demos, I haven’t run the code as part of the document rendering as the output is large and it affects that state of Julia in ways that are not helpful.\n\n\n\n\n\n\nWarning\n\n\n\nThere’s a lot of configuration details in the section on using packages. It’s not critical to absorb it all at this point, but it’s here for when you need it. In part I went into detail as I was trying to understand the details myself.",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#style-guide",
    "href": "notes/notes4.html#style-guide",
    "title": "Notes 4: Managing Julia",
    "section": "Style guide",
    "text": "Style guide\nSome highlights from the Julia style guide include:\n\n4 spaces per indentation level\nAppend ! to names of functions that modify inputs. Mutated input(s) should appear first in the arguments.\nType and module names: use capitalized/UpperCamelCase.\nFunction names: use lower-case squashed names (with underscores/snake_case as needed) (e.g., isequal or possibly is_equal).\nUse isa and &lt;: rather than == for type comparisons.\nFor hard-coded numbers, use Ints rather than Floats for integer-valued numbers, e.g., 2 * x rather than 2.0 * x. (The latter will unnecessarily force conversion to Float when x is an Int.)",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#file-operations-io",
    "href": "notes/notes4.html#file-operations-io",
    "title": "Notes 4: Managing Julia",
    "section": "File operations (I/O)",
    "text": "File operations (I/O)\nHere are some basic examples of reading data from files.\n\nfilename = joinpath(\"..\", \"data\", \"cpds.csv\")\nlines = readlines(filename)\n\nusing CSV, DataFrames\n\ndata = CSV.read(filename, DataFrame);\ntypeof(data.year)\n\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\n\ntypeof(data.country)\n\n\nPooledVector{String15, UInt32, Vector{UInt32}} (alias for PooledArrays.PooledArray{String15, UInt32, 1, Array{UInt32, 1}})",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#packages",
    "href": "notes/notes4.html#packages",
    "title": "Notes 4: Managing Julia",
    "section": "Packages",
    "text": "Packages\nA package is the way that code is distributed as a bundle of add-on functionality to a language. Julia packages contain source code files, tests, documentation, and metadata (e.g., about dependence on other packages).\n\nUsing packages\nWe can make variables/functions from packages available with either using or import. using brings all the variables into the current namespace, while import makes them available via module.variable. So import is cleaner and safer in terms of name conflicts.\nI’m having some trouble getting this to display correctly in the rendered document, so the code chunks below have not been run.\n\nA = rand(3, 3);\neigvals(A)\n\n\nimport LinearAlgebra\neigvals(A)\n\n\nLinearAlgebra.eigvals(A)\n\nIf we want to access variables/functions from a file, we can use include, which will evaluate the file contents in the global scope. This is used a lot in packages to allow the package code to be split up into multiple files.\n\ninclude(\"linecount.jl\")\nlinecount(\"notes4.qmd\")\n\n592\n\n\n\n\nInstalling and managing packages on your system\nThe examples below show how things work on the SCF Linux machines, but the situation should be similar on your personal machine.\n\nDepots\nA depot is where installed packages, projects/environments, and various other things are stored.\nYou can see the various depots via\n\nBase.DEPOT_PATH\n\n3-element Vector{String}:\n \"/accounts/vis/paciorek/.julia\"\n \"/system/linux/julia-1.10.4/local/share/julia\"\n \"/system/linux/julia-1.10.4/share/julia\"\n\n\n\n\nPackage installation locations\nJulia will look in various locations for packages that are available to be used. The locations can be seen via\n\nBase.load_path()\n\n3-element Vector{String}:\n \"/accounts/vis/paciorek/.julia/environments/v1.10/Project.toml\"\n \"/system/linux/julia-1.10.4/share/julia/stdlib/v1.10\"\n \"/usr/local/linux/julia-1.10.4/share/julia/environments/v1.10/Project.toml\"\n\n\nNote that this includes the active project, the standard library, and (in some cases) a system project. More on projects in a bit.\nJulia comes with some packages pre-installed. These include LinearAlgebra, Distributed, Random, and some others.\nYou can see them in the stdlib directory in the main system depot, e.g.,\nls /usr/local/linux/julia-1.10.4/share/julia/stdlib/v1.10/\nPackages that you (or a system administrator) install will be in the packages subdirectory of the depots.\nFor example, for packages you install:\nls ~/.julia/packages\nIn some cases (probably not on your personal machine) there will be system-installed packages:\nls /usr/local/linux/julia-1.10.4/share/julia/packages\nAs you’d expect, a given package will have various versions, and multiple versions can be installed at the same time.\ngrep version ~/.julia/packages/BenchmarkTools/*/Project.toml\nIn general, Julia will avoid installing multiple copies of the same package version in different locations on a machine/system.\n\n\nPrecompilation\nJulia will often precompiled packages. This is separate from runtime just-in-time (JIT) compilation of code. I have not had a chance to understand what the precompilation is doing.\n\n\n\nProjects/environments\nA project (or environment) defines a set of packages and their versions. An important aspect of this is reproducibility.\nThe Project.toml file for a project gives high-level information about a project, including the direct package dependencies.\ncat ~/.julia/environments/v1.10/Project.toml\nThe Manifest.toml file gives the detailed dependency information, including package versions for all direct and indirect package dependencies.\ncat ~/.julia/environments/v1.10/Manifest.toml\nThese files can be handled via version control to ensure reproducibility.\nAs noted previously, multiple projects can make use of the same installed package version.\n\n\nPkg: the Julia package manager\nThe package manager allows you to activate projects and add packages to projects, among other things.\nYou can use the package manager either in the Pkg REPL by pressing ], or by calling the Pkg API via Pkg., after using Pkg. (If you use ], you can use the Backspace key to get back to the regular Julia REPL.)\nHere we’ll use the API as I think that makes the demo clearer.\n\nActivating a project\nAnytime you use Julia, you’ll be working in the context of a project. By default this will be your default project, which is located at ~/.julia/environments/&lt;version&gt;.\n\nusing Pkg\n\nBase.active_project()\nPkg.status()\n\nStatus `~/.julia/environments/v1.10/Project.toml`\n  [6e4b80f9] BenchmarkTools v1.5.0\n  [078ea971] CPpkg v1.0.0-DEV `/accounts/vis/paciorek/.julia/dev/CPpkg#main`\n  [336ed68f] CSV v0.10.14\n  [052768ef] CUDA v5.4.2\n  [a93c6f00] DataFrames v1.6.1\n  [31a5f54b] Debugger v0.7.9\n  [31c24e10] Distributions v0.25.109\n  [e2ba6199] ExprTools v0.1.10\n  [6a86dc24] FiniteDiff v2.23.1\n  [26cc04aa] FiniteDifferences v0.12.32\n  [7073ff75] IJulia v1.24.2\n⌃ [682c06a0] JSON v0.21.3\n  [14b8a8f1] PkgTemplates v0.7.50\n  [91a5bcdd] Plots v1.40.4\n  [4c0109c6] QuartoNotebookRunner v0.12.0 `https://github.com/PumasAI/QuartoNotebookRunner.jl.git#main`\n  [6f49c342] RCall v0.14.1\n  [276daf66] SpecialFunctions v2.4.0\n  [fd094767] Suppressor v0.2.7\n  [7feac75d] TestPkg v1.0.0-DEV `/accounts/vis/paciorek/.julia/dev/TestPkg#main`\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n\nWe can activate (and create if needed) a project (results not shown):\n\nPkg.activate(\"MyNewProject\")\nPkg.status()\n\n\n\nAdding packages to a project\nBefore you can invoke using or import to access a package for the first time in the context of a project, you’ll need to “add” the package to the project (but see caveats in the next section).\n\nusing Pkg\nPkg.add(\"BenchmarkTools\")\n# Or to add a specific version:\n# Pkg.add(name = \"BenchmarkTools\", version = \"1.5.0\")\nusing BenchmarkTools\n\nJulia will prompt you to add a package if it’s not part of a project. And if the version of the package is not installed anywhere on your system, it will download and install it (to ~/.julia/packages). Information about what packages/versions are available and where they are on the internet is contained in a registry.\n\n\n\nIsolated projects\nI don’t fully understand the reasoning, but if you activate a project, you still have access to packages from your default project and (if it exists) the system default project. So this seems to make the project not fully isolated. According to the Julia docs, this is because those default projects are shared environments.\nIn the following, note that I never added JSON to the active project, but it’s accessible from my default project.\n\nBase.load_path()\n\n3-element Vector{String}:\n \"/accounts/vis/paciorek/.julia/environments/v1.10/Project.toml\"\n \"/system/linux/julia-1.10.4/share/julia/stdlib/v1.10\"\n \"/usr/local/linux/julia-1.10.4/share/julia/environments/v1.10/Project.toml\"\n\n\n\nusing JSON\n\nSo good practice when trying to isolate a project is probably to use Pkg.add to add any packages you use to your project, rather than relying on those packages being available from elsewhere on the load path. Alternatively you may want to avoid adding packages to the default project entirely.\n\n\n\n\n\n\nExercise\n\n\n\nCreate a new project. Add some of the packages that we’ve used so far to the project (e.g, Distributions and Plots). Switch back and forth between your new project and the default project. Figure out where the packages are installed on your filesystem.",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#creating-packages",
    "href": "notes/notes4.html#creating-packages",
    "title": "Notes 4: Managing Julia",
    "section": "Creating packages",
    "text": "Creating packages\nA package is the way of distributing additional Julia functionality. It generally contains modules (containing code), tests, and documentation. You can also register your package to the Julia General Registry, so that it is easily available via Pkg.add.\n\nCreating your package\nThe Julia documentation provides a nice overview of creating a package. One standard way is to use the PackageTemplates package.\n\nusing PkgTemplates\n\nt = Template(;\n           user=\"paciorek\",\n           authors=[\"Christopher Paciorek\"],\n           plugins=[\n               License(name=\"MIT\"),\n               Git(),\n               GitHubActions(),\n           ],\n)\n\nt(\"CPpkg\") \n\nRunning t(CPpkg) produces this output, indicating what is happening on the filesystem:\njulia&gt; t(\"CPpkg\")\n[ Info: Running prehooks\n[ Info: Running hooks\n  Activating project at `~/.julia/dev/CPpkg`\n  No Changes to `~/.julia/dev/CPpkg/Project.toml`\n  No Changes to `~/.julia/dev/CPpkg/Manifest.toml`\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds\n        Info We haven't cleaned this depot up for a bit, running Pkg.gc()...\n      Active manifest files: 3 found\n      Active artifact files: 139 found\n      Active scratchspaces: 5 found\n     Deleted 5 package installations (1.827 MiB)\n  Activating project at `~/.julia/environments/v1.10`\n[ Info: Running posthooks\n[ Info: New package is at /accounts/vis/paciorek/.julia/dev/CPpkg\n\"/accounts/vis/paciorek/.julia/dev/CPpkg\"\n\n\nParts of the package\n\nCode in src.\nWe’ll look at the basic structure of code in src as outlined in the documentation.\nThen we’ll add some functionality to src/CPpkg.jl or to another file that we include via include(\"functions.jl\").\n\n\nGit repository\nRunning the template created a Git repository for the package. Nice.\ncd ~/.julia/dev/CPpkg\ngit status\nls -l .git\nNote that because a Git repository was created, we need to commit any changes to src to have them reflected in the package when we use it in Julia (in a moment).\ngit add src/CPpkg.jl\ngit commit -m'Add initial test function.'\n\n\nTesting\nRunning the template created a skeleton of a test directory. Also nice.\nEven nicer, it created the GitHub Actions workflow (.github/workflows/CI.yml) so that your tests would run via continuous integration on GitHub whenever you push changes to the main branch of the repository.\n\n\nAccessing a local package\nWe can try out the (local) package like this:\n\nPkg.add(path=\"/accounts/vis/paciorek/.julia/dev/CPpkg\")\nusing CPpkg\ntest()\n\nIt looks like we add a package directly from GitHub like this:\n\nPkg.add(url=\"https://github.com/JuliaLang/Example.jl\", rev=\"master\") \n\n\n\n\nLooking at an example package\nLet’s look at the BenchmarkTools package as an example package whose structure looks fairly straightforward. The file src/BenchmarkTools.jl is the entry point that defines the package and pulls in code from the other source files.\n\nDocumentation\nIt appears that ?BenchmarkTools shows the contents of README.md. There is also information in docs, but I haven’t figured out the details.\nWe can see docstrings in the src files though some are fairly brief. execution.jl shows the extensive docstring for @benchmark though it uses different syntax than seen earlier in these notes, using @doc raw\"\"\" and julia-repl.\n\n\nExported objects\nIf we look in BenchmarkTools.jl (in ~/.julia/packages/BenchmarkTools/&lt;version_hash&gt;/src), we see that loadparams! from parameters.jl is exported, but estimate_overhead is not. The exports define the user interface or “API” of the package.\n\nusing BenchmarkTools\nloadparams!\n\nloadparams! (generic function with 3 methods)\n\n\n\nestimate_overhead\n\nLoadError: UndefVarError: `estimate_overhead` not defined\nUndefVarError: `estimate_overhead` not defined\n\n\nWe can access estimate_overhead in the BenchmarkTools module:\n\nimport BenchmarkTools\nBenchmarkTools.estimate_overhead\n\nestimate_overhead (generic function with 1 method)\n\n\n\n\nAdditional modules\nOne can organize code within a package into multiple modules nested within the main module for the package.\nFor example, in the LinearAlgebra package (part of Julia’s standard library), src/blas.jl contains the BLAS module. To make it available, LinearAlgebra.jl uses include(\"blas.jl\") and export BLAS. Here’s how we can access the BLAS (sub)module:\n\nimport LinearAlgebra\nLinearAlgebra.BLAS.get_num_threads()\n\n4\n\n\nor\n\nusing LinearAlgebra\nBLAS.get_num_threads()\n\n4\n\n\n\n\n\n\n\n\nExercise\n\n\n\nExplore the structure of a package of interest to you in ~/.julia/packages. (You’ll need to add the package to invoke installation if it’s not already part of one of your projects.)",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#errors-and-messaging",
    "href": "notes/notes4.html#errors-and-messaging",
    "title": "Notes 4: Managing Julia",
    "section": "Errors and messaging",
    "text": "Errors and messaging\n\nTracebacks\nWe can see the function frames if we force an error to occur.\nHere we have a function that uses recursion, but the same thing happens when the nested function calls are not recursive.\n\nfunction factorial(x)\n  if x == 0\n    sqrt(-1)\n    return 1\n  else\n    return x*factorial(x-1)\n  end\nend\n\nfactorial(3)\n\nLoadError: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nDomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n\nStacktrace:\n [1] throw_complex_domainerror(f::Symbol, x::Float64)\n   @ Base.Math ./math.jl:33\n [2] sqrt\n   @ ./math.jl:686 [inlined]\n [3] sqrt(x::Int64)\n   @ Base.Math ./math.jl:1578\n [4] factorial(x::Int64)\n   @ Main ./In[15]:3\n [5] factorial(x::Int64) (repeats 3 times)\n   @ Main ./In[15]:6\n [6] top-level scope\n   @ In[15]:10\n\n\n\n\nFinding the source code\nIf I wanted to dig into the source code to better understand an error or try to understand how it works, here’s an example of finding the functions indicated in the traceback:\npaciorek@gandalf:~&gt; type julia\njulia is /usr/local/linux/julia-1.10.4/bin/julia\npaciorek@gandalf:~&gt; cd /usr/local/linux/julia-1.10.4\npaciorek@gandalf:/usr/local/linux/julia-1.10.4&gt; find . -name math.jl\n./share/julia/base/math.jl\n./share/julia/test/math.jl\n\n\nTry-catch\nOne standard way to make your code more robust is to anticipate where errors may occur and give informative messaging and/or proceed despite the error.\n\ntry\n    data = open(\"bad_file.txt\")\ncatch exc\n    println(\"Something went wrong: $exc\")\nend\n\nSomething went wrong: SystemError(\"opening file \\\"bad_file.txt\\\"\", 2, nothing)\n\n\n\n\nWarnings and logging\nYou can print out useful information with @info, @warn, and @error, going from information messages to more serious issues. The latter doesn’t actually throw a formal exception (error) and stop execution, it just indicates a less extreme error from which the code can still proceed.\nUsers can then control the level of logging information that they see. In this example we set the logging level for warnings and more serious messages, so the Info message is not shown. (This code is not run here because the rendering process is causing problems.)\n\nfunction test() \n    println(\"Hello from test.\")\n    @info \"Some info\"\n    @warn \"A warning\"\n    @error \"An error\"\nend\n\nusing Logging\n\n# Show warning messages and above (this excludes info messages)\nglobal_logger(ConsoleLogger(stderr, Logging.Warn))\n\ntest()\n\nThese are examples of macros, which start with @.\n\n\nDebugging statements\n\nx = (3,5)\n@show x\n\n@debug \"The sum of some values $(sum(rand(100)))\"\n\nx = (3, 5)\n\n\nThe debug statement is only run if debugging is enabled (e.g., via JULIA_DEBUG=all when invoking Julia or in the Julia interactive session).\n\nENV[\"JULIA_DEBUG\"] = \"all\"\n@debug \"The sum of some values $(sum(rand(100)))\"\n\n┌ Debug: The sum of some values 47.96083233911496\n└ @ Main In[18]:2\n\n\nWe’ll see the Julia debugger (and possibly Julia debugging in VS Code) later.",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#assertions",
    "href": "notes/notes4.html#assertions",
    "title": "Notes 4: Managing Julia",
    "section": "Assertions",
    "text": "Assertions\nOne can use assertions to check values for robustness or as sanity checks while developing code.\n\nfunction mysum(x, y)\n  @assert(isa(x, Number) && isa(y, Number), \"non-numeric inputs\")\n  return x + y\nend\n\nmysum (generic function with 1 method)\n\n\nOf course that’s not a good example as we can more robustly and elegantly deal with type checking by declaring types for the function arguments!\n\nExceptions\nJulia has a variety of kinds of runtime errors (aka exceptions).\nHere’s a DomainError.\n\nsqrt(-1)\n\nLoadError: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nDomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n\nStacktrace:\n [1] throw_complex_domainerror(f::Symbol, x::Float64)\n   @ Base.Math ./math.jl:33\n [2] sqrt\n   @ ./math.jl:686 [inlined]\n [3] sqrt(x::Int64)\n   @ Base.Math ./math.jl:1578\n [4] top-level scope\n   @ In[20]:1\n\n\nAnd here’s how we can trap an error and throw an exception (again a DomainError) ourselves.\n\nfunction mysqrt(x)\n   if x &lt; 0\n      throw(DomainError(x, \"sqrt: input must be non-negative.\"))\n   else\n      return sqrt(x)\n   end\nend\n\nmysqrt(-3)\n\nLoadError: DomainError with -3:\nsqrt: input must be non-negative.\nDomainError with -3:\nsqrt: input must be non-negative.\n\nStacktrace:\n [1] mysqrt(x::Int64)\n   @ Main ./In[21]:4\n [2] top-level scope\n   @ In[21]:10",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#documentation-1",
    "href": "notes/notes4.html#documentation-1",
    "title": "Notes 4: Managing Julia",
    "section": "Documentation",
    "text": "Documentation\nDocstrings come before the function in triple quotes. Note that I figured out the syntax below (e.g., use of jldoctest) by looking at Julia source code.\n\"\"\"\n    times3(x)\n\nMultiplies the input by three.\n\nThe return type is the same as the input type.\n\n# Examples\n```jldoctest\njulia&gt; x = 7.5;\njulia&gt; times3(x)\n22.5\n\njulia&gt; x = [7.5, 3];\njulia&gt; times3.(x)\n2-element Vector{Float64}:\n 22.5\n  9.0\n```\n\"\"\"\nfunction times3(x)\n  return 3*x\nend\nIf you do that, you can then do ?times3 to see the docstring. Nice.\n\n\n\n\n\n\nTips for docstrings\n\n\n\n\nAs many of you have probably discoverd using a Chatbot is a good way to get a first draft of a doc string.\nFollowing the format/style of docstrings for base Julia functions is a good idea.\nProvide examples! (You know that when you look at docstrings, that’s often what you want.)",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#testing-1",
    "href": "notes/notes4.html#testing-1",
    "title": "Notes 4: Managing Julia",
    "section": "Testing",
    "text": "Testing\nWe’ll cover testing separately.\nYou can run the tests for an existing package like this:\n\nPkg.test(\"CSV\")",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "notes/notes4.html#macros",
    "href": "notes/notes4.html#macros",
    "title": "Notes 4: Managing Julia",
    "section": "Macros (@)",
    "text": "Macros (@)\nMacros modify existing code or generate new code. They’re a convenient shortcut to do a variety of things.\nHere’s a basic example of timing some code:\n\n@time 3 + 7\n\n  0.000001 seconds\n\n\n10\n\n\nThe @. broadcasting macro ‘distributes’ the . broadcasting to all operations. These two lines of code are equivalent.\n\n@. x^2 + y^2 ≤ 1\nx.^2 .+ y.^2 .≤ 1\n\nMacros execute when the Julia code is parsed, before the code is actually run.",
    "crumbs": [
      "Course Notes",
      "Notes 4: Managing Julia"
    ]
  },
  {
    "objectID": "howtos/accessJulia.html",
    "href": "howtos/accessJulia.html",
    "title": "Accessing Julia",
    "section": "",
    "text": "Julia should be straightforward to install on your own computer.\nJulia is also available on all the SCF machines. If you’re in a shell/terminal, you’ll first need to run module load julia.",
    "crumbs": [
      "How tos",
      "Accessing Julia"
    ]
  },
  {
    "objectID": "howtos/accessJulia.html#installing-and-accessing-julia",
    "href": "howtos/accessJulia.html#installing-and-accessing-julia",
    "title": "Accessing Julia",
    "section": "",
    "text": "Julia should be straightforward to install on your own computer.\nJulia is also available on all the SCF machines. If you’re in a shell/terminal, you’ll first need to run module load julia.",
    "crumbs": [
      "How tos",
      "Accessing Julia"
    ]
  },
  {
    "objectID": "howtos/accessJulia.html#using-julia-packages",
    "href": "howtos/accessJulia.html#using-julia-packages",
    "title": "Accessing Julia",
    "section": "Using Julia packages",
    "text": "Using Julia packages\nOne gets access to a Julia package using using &lt;packageName&gt; (or import &lt;packageName).\nIf the package is not part of your project (all Julia work is done in a project), you’ll need to add it like this, using the BenchmarkTools package as an example:\nusing Pkg\nPkg.add(\"BenchmarkTools\")\nIf the package is not installed on the machine, Julia will prompt you to install it. Packages will generally be installed in ~/.julia/packages (where ~ is shorthand for the location of your home directory).",
    "crumbs": [
      "How tos",
      "Accessing Julia"
    ]
  },
  {
    "objectID": "howtos/accessJulia.html#using-julia-in-jupyter-notebooks",
    "href": "howtos/accessJulia.html#using-julia-in-jupyter-notebooks",
    "title": "Accessing Julia",
    "section": "Using Julia in Jupyter notebooks",
    "text": "Using Julia in Jupyter notebooks\nTo use Julia in a notebook on the SCF JupyterHub, you can just select Julia as the kernel from the dropdown in the top right.\nTo use Julia in a notebook on your own machine, you need to install the Julia kernel for Jupyter.\nusing Pkg\nPkg.add(\"IJulia\")\ninstallkernel(\"Julia\")\nThat should create a kernel called “Julia” that you can select as the kernel when you are in a Jupyter notebook.",
    "crumbs": [
      "How tos",
      "Accessing Julia"
    ]
  },
  {
    "objectID": "howtos/installGit.html",
    "href": "howtos/installGit.html",
    "title": "Installing Git",
    "section": "",
    "text": "Here are some instructions for installing Git on your computer. You should use Git to manage your work on your final project. You may also want to use it for your problem set and presentation work.\nYou can install Git by downloading and installing the correct binary from here.\nFor macOS, we recommend using the Homebrew option.\nGit comes installed on the SCF, so if you login to an SCF machine and want to use Git there, you don’t need to install Git.",
    "crumbs": [
      "How tos",
      "Installing Git"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "UNDER CONSTRUCTION - PROVIDED FOR INFORMATION BUT NOT FINAL/DEFINITIVE",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#objectives-of-the-course",
    "href": "syllabus.html#objectives-of-the-course",
    "title": "Syllabus",
    "section": "Objectives of the course",
    "text": "Objectives of the course\nThe goals of the course are that, by the end of the course, students be able to:\n\nhave a solid understanding of general programming concepts and principles, including parallelization for CPUs and GPUs; and\nbe able to program effectively using Julia.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#topics",
    "href": "syllabus.html#topics",
    "title": "Syllabus",
    "section": "Topics",
    "text": "Topics\nThese are tentative (particularly in terms of exact timing and the later weeks), as the course has never been taught before.\n\nWeek 1: Julia syntax, data structures and basic types, functional programming, memory and copying, variable scope\nWeek 2: Methods and multiple dispatch, types, managing Julia (packaging, debugging, testing, exceptions, etc.)\nWeek 3: Efficiency and memory use, just-in-time (JIT) compilation\nWeek 4: Parallel programming concepts and parallelization in Julia\nWeek 5: Parallel programming in Python and additional topics in parallelization\nWeek 6: Numerical computation in Julia (floating point concepts, linear algebra, optimization\nWeek 7: Student project presentations and other topics",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-content",
    "href": "syllabus.html#course-content",
    "title": "Syllabus",
    "section": "Course content",
    "text": "Course content\nKey websites for the course are:\n\nThis course website, which is hosted on GitHub Pages, and the GitHub repository containing the source materials: https://github.com/berkeley-stat244/spring-2025. The main course content will be notes prepared by me under the Notes dropdown and student presentations on various topics.\nSCF tutorials for additional content: https://statistics.berkeley.edu/computing/training/tutorials\nEd Discussion site for discussions/Q&A: https://edstem.org/us/courses/73174/discussion\nGradescope for problem sets: https://www.gradescope.com/courses/949978\n\nThere will be no course capture for this course, in part because of the room we are in and in part because of the seminar/special topics nature of the course. I expect you to attend all classes, except for illness or with advance notice of well-justified travel.\nWhile there is a bCourses site for the course, we won’t use it at all, as far as I anticipate at the moment.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-culture",
    "href": "syllabus.html#course-culture",
    "title": "Syllabus",
    "section": "Course culture",
    "text": "Course culture\nThis is a small class, a graduate class, and essentially a special topics/seminar class. That has the following implications.\nI expect a corresponding degree of maturity from all students, including the small number of undergraduates who might take the class. Among other things, this means trying to not stress about grading, being comfortable with ambiguity (in terms of content, expectations, and grading), being curious, and fully participating in class, even if you feel a bit uncomfortable because you think it might reveal some lack of knowledge or understanding on your part.\nEvaluation/grading will be somewhat informal and based in part on your contributions to the class community (either to the in-class discussion or the Ed discussion board), as well as completion of problem sets, and my assessment of student project/presentations. See more below.\nFurthermore, I am not an expert in Julia! Part of my motivation for teaching the class was to learn Julia myself (as well as more about working with GPUs), which I’ve done some of in preparation for the class and to some degree will make up for remaining gaps based on my larger expertise in this sort of programming (in particular experience with R and Python). But there’s a lot I don’t know, and there will be lots of questions I’m not sure how to answer in the moment in class. Contributing your thoughts in class or on Ed is part of your responsibility in the class.\nPlease do not use phones during class and limit laptop use to the material being covered.\nFinally, if you have suggestions for how to make the course better, including how we use time in class, please let me know.\n\nEd culture\nPlease follow these guidelines for choosing how to post on Ed:\n\nPublic (non-anonymous) posts: I highly encourage public posts about course topics/concepts and topics discussed in class as well as questions about problem set problems, as that is the only way to contribute to the course discussion.\n\nPlease DO NOT post public messages anonymously.\n\nPrivate (but non-anonymous) posts:\n\nIf you feel very uncomfortable asking a question about the items mentioned above, you can make a private (but non-anomymous) post. But it won’t “count” in terms of your class participation.\nIn some cases, I may ask/encourage you to make your post public, so I can respond such that all students see my thoughts.\nQuestions specific to your project or presentation are also appropriate for private posts, but in some cases you might want to elicit feedback from other students, in which case a public post is entirely welcome.\nI welcome feedback about the course, particularly given it is the first time offered and there will be lots of things that could be improved.\n\nAnonymous private posts:\n\nIf you’d like to leave anonymous feedback via a private post to me, you can. I prefer to know about it rather than for you to keep it to yourself, but I encourage you not to make it anonymous.\nI won’t answer general topic/course questions that are posted anonymously, whether public or private.\n\nAnonymous public posts: Please DO NOT make such posts. I don’t think it is conducive to productive discussion in a community.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-material",
    "href": "syllabus.html#course-material",
    "title": "Syllabus",
    "section": "Course material",
    "text": "Course material\n\nPrimary materials: Course notes on the website and student presentation materials, plus SCF tutorials.\nAdditional materials:\n\nThink Julia book\nJulia manual\nPer-Olof Persson’s Berkeley Math 124 materials\n\nSee also the Statistics 243 course material list for references on numerical computing and software tools (bash, Quarto).",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#computing-resources",
    "href": "syllabus.html#computing-resources",
    "title": "Syllabus",
    "section": "Computing Resources",
    "text": "Computing Resources\nMost work for the course can be done on your laptop. Later in the course (in a cfew weeks!), we’ll also use the Statistics Department Linux cluster for access to GPUs. Please sign up for an SCF account now if you don’t have one.\nThe software needed for the course is as follows:\n\nJulia\nQuarto\nPython (the Miniforge installation of Conda is recommended but by no means required)\nGit\n\nSee the “how tos” in the left sidebar for tips on software installation and usage.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#course-requirements-and-grading",
    "href": "syllabus.html#course-requirements-and-grading",
    "title": "Syllabus",
    "section": "Course requirements and grading",
    "text": "Course requirements and grading\n\nCourse grades\nGrading will be based on a combination of your general participation (in class and on the discussion forum), completion of several problem sets, and either an in-class presentation on a topic or a project. I have a number of topics I’d like to see covered by student presentation but I am open to other ideas as well. Projects and in-class presentations can be on your own or in pairs.\nGrades will generally be As and Bs, unless I assess a lack of engagement on your part.\n\nProblem sets\nPlease prepare your assignments using Quarto (or a Jupyter notebook), output to PDF and submitted to Gradescope. Answers should consist of textual response (and any useful mathematical expressions as appropriate), with key chunks of code embedded within the document.\nYou must include a “Collaboration” section in which you indicate any other students you worked with and describing the nature of any use of ChatBots/LLMs. If you did not collaborate with anyone else (including said AIs), simply state that.\nYou’re welcome to consult with classmates on problem set problems, and I encourage it. You can discuss a problem with another student, brainstorm approaches, and share code syntax (generally not more than one line) on how to do small individual coding tasks within a problem.\n\nYou should not ask another student for complete code or solutions, or look at their code/solution.\nYou should not share complete code or solutions with another student or on Ed Discussion.\n\nRemember this is a small class with one goal that you learn how to effectively program, in Julia in particular. There’s no point in copying code in bulk from another student or a ChatBot, because it won’t help you learn programming/Julia. For that you need to wrestle with the concepts/syntax and develop “muscle memory”.\nI am still considering how I will grade problem sets, given there is no GSI and the nature of the class. They will either be graded complete/incomplete or on a 4 point scale:\n\n0 = no credit,\n1 = partial credit (you did some of the problems but not all),\n2 = generally satisfactory (you tried everything but there were pieces of what you did that didn’t completely/correctly solve or present/explain one or more problems), and\n3 = full credit.\n\n\n\nProjects\nI’m expecting that many of you will want to come up with your own final project. You’ll need to discuss the topic with me in advance. It should involve programming in Julia, though use of Python for GPU computations may be ok too. I may also have a couple project topics that you could choose from if you don’t have a project idea and want to do a project rather than doing class presentation(s).\nIn some cases a final project could overlap/be combined with the class presentation topics, such as a project focused on optimization, use of special matrices, AI/ML, or using GPUs. You would present your project to the class (probably in the last week or two) and in the process of doing so, you can talk about the general context as well as your specific work.\nYou should use Git to manage the code in your project. The result does not have to be, but could be, a Julia package.\n\n\nPresentations\nStudent presentations will be a core part of the content of the course. I have some specific ideas of topics that I think would be good, but I am also open to your ideas of topics you’d be excited to dive into and present.\nI expect you to do a deep dive on the topic, and while I don’t expect you to be an expert in a week or two, I do expect you to have done a some research and experimentation and pulled together a clear, in-depth presentation focused on examples/demonstration/code syntax, and be ready to answer questions from the class. I will discuss the focus/goal of the presentation/topic with the student(s) when the topic is chosen and then we’ll have a quick interim “progress” discussion a few days before the presentation. I’m expecting the presentations would be 15-30 minutes, depending on the topic.\nI highly recommend using Quarto to prepare presentation materials, but I am also happy to discuss other possibilities with you. We’ll need to figure out a good way to make the final materials available through the website, probably through pull requests made to the course GitHub site.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#accomodations-for-students-with-disabilities",
    "href": "syllabus.html#accomodations-for-students-with-disabilities",
    "title": "Syllabus",
    "section": "Accommodations for Students with Disabilities",
    "text": "Accommodations for Students with Disabilities\nPlease see me as soon as possible if you need particular accommodations, and we will work out the necessary arrangements. That said, given the lack of exams, there may be no need for an accommodation even if you have a disability.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "syllabus.html#campus-honor-code",
    "href": "syllabus.html#campus-honor-code",
    "title": "Syllabus",
    "section": "Campus Honor Code",
    "text": "Campus Honor Code\nThe following is the Campus Honor Code. With regard to collaboration and independence, please see my rules regarding problem sets above – Chris.\nThe student community at UC Berkeley has adopted the following Honor Code: “As a member of the UC Berkeley community, I act with honesty, integrity, and respect for others.” The hope and expectation is that you will adhere to this code.\nCollaboration and Independence: Reviewing lecture and reading materials and studying for exams can be enjoyable and enriching things to do with fellow students. This is recommended. However, unless otherwise instructed, homework assignments are to be completed independently and materials submitted as homework should be the result of one’s own independent work.\nCheating: A good lifetime strategy is always to act in such a way that no one would ever imagine that you would even consider cheating. Anyone caught cheating on a quiz or exam in this course will receive a failing grade in the course and will also be reported to the University Center for Student Conduct. In order to guarantee that you are not suspected of cheating, please keep your eyes on your own materials and do not converse with others during the quizzes and exams.\nPlagiarism: To copy text or ideas from another source without appropriate reference is plagiarism and will result in a failing grade for your assignment and usually further disciplinary action. For additional information on plagiarism and how to avoid it, see, for example: http://gsi.berkeley.edu/teachingguide/misconduct/prevent-plag.html.\nAcademic Integrity and Ethics: Cheating on exams and plagiarism are two common examples of dishonest, unethical behavior. Honesty and integrity are of great importance in all facets of life. They help to build a sense of self-confidence, and are key to building trust within relationships, whether personal or professional. There is no tolerance for dishonesty in the academic world, for it undermines what we are dedicated to doing – furthering knowledge for the benefit of humanity.\nYour experience as a student at UC Berkeley is hopefully fueled by passion for learning and replete with fulfilling activities. And we also appreciate that being a student may be stressful. There may be times when there is temptation to engage in some kind of cheating in order to improve a grade or otherwise advance your career. This could be as blatant as having someone else sit for you in an exam, or submitting a written assignment that has been copied from another source. And it could be as subtle as glancing at a fellow student’s exam when you are unsure of an answer to a question and are looking for some confirmation. One might do any of these things and potentially not get caught. However, if you cheat, no matter how much you may have learned in this class, you have failed to learn perhaps the most important lesson of all.",
    "crumbs": [
      "Syllabus"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "License",
    "section": "",
    "text": "This work is licensed under a Creative Commons Attribution 4.0 International License.",
    "crumbs": [
      "License"
    ]
  },
  {
    "objectID": "ps/ps1.html",
    "href": "ps/ps1.html",
    "title": "Problem Set 1",
    "section": "",
    "text": "I haven’t fully worked these problems myself, so if you run into any strange issues, please post on Ed as there could be mistakes/oversights on my part.\nPlease submit as a PDF to Gradescope.\nPlease generate the PDF using Quarto. Feel free to work in a Jupyter notebook and then convert to Quarto before rendering to PDF. Other formats that look professional and are designed for working with code and math notation may also be fine - just check with me via a public post on Ed first.\nRemember to note at the start of your document the names of any other students that you worked with on the problem set (or indicating you didn’t work with anyone if that was the case) and then indicate in the text or in code comments any specific ideas or code you borrowed from another student or any online reference (including ChatGPT or the like).\nFor problems 1 and 5, your solution should not just be code - you should have text describing how you approached the problem and what decisions/conclusions you made, though for simple problems, this can be quite short. Your code should have comments indicating what each function or block of code does, and for any lines of code or code constructs that may be hard to understand, a comment indicating what that code does.\nYou do not need to (and should not) show exhaustive output, but in general you should show short examples of what your code does to demonstrate its functionality. The output should be produced as a result of the code chunks being run during the rendering process, not by copy-pasting of output from running the code separately (and definitely not as screenshots).\nI do not recommend writing initial answers using a ChatBot, as I think you are likely to fool yourself in terms of how much you are learning about Julia and programming concepts/skills more generally. But it’s up to you to decide how heavily to rely on a ChatBot. And refining your initial answers using a ChatBot seems like a good strategy. Using your own knowledge and information online to check the results of a ChatBot and using a ChatBot to check your own coding can both be important/useful.",
    "crumbs": [
      "Problem Sets",
      "Problem Set 1"
    ]
  },
  {
    "objectID": "ps/ps1.html#comments",
    "href": "ps/ps1.html#comments",
    "title": "Problem Set 1",
    "section": "",
    "text": "I haven’t fully worked these problems myself, so if you run into any strange issues, please post on Ed as there could be mistakes/oversights on my part.\nPlease submit as a PDF to Gradescope.\nPlease generate the PDF using Quarto. Feel free to work in a Jupyter notebook and then convert to Quarto before rendering to PDF. Other formats that look professional and are designed for working with code and math notation may also be fine - just check with me via a public post on Ed first.\nRemember to note at the start of your document the names of any other students that you worked with on the problem set (or indicating you didn’t work with anyone if that was the case) and then indicate in the text or in code comments any specific ideas or code you borrowed from another student or any online reference (including ChatGPT or the like).\nFor problems 1 and 5, your solution should not just be code - you should have text describing how you approached the problem and what decisions/conclusions you made, though for simple problems, this can be quite short. Your code should have comments indicating what each function or block of code does, and for any lines of code or code constructs that may be hard to understand, a comment indicating what that code does.\nYou do not need to (and should not) show exhaustive output, but in general you should show short examples of what your code does to demonstrate its functionality. The output should be produced as a result of the code chunks being run during the rendering process, not by copy-pasting of output from running the code separately (and definitely not as screenshots).\nI do not recommend writing initial answers using a ChatBot, as I think you are likely to fool yourself in terms of how much you are learning about Julia and programming concepts/skills more generally. But it’s up to you to decide how heavily to rely on a ChatBot. And refining your initial answers using a ChatBot seems like a good strategy. Using your own knowledge and information online to check the results of a ChatBot and using a ChatBot to check your own coding can both be important/useful.",
    "crumbs": [
      "Problem Sets",
      "Problem Set 1"
    ]
  },
  {
    "objectID": "ps/ps1.html#problems",
    "href": "ps/ps1.html#problems",
    "title": "Problem Set 1",
    "section": "Problems",
    "text": "Problems\n\nWrite a function that implements a basic version of Newton’s method for minimizing a function of one variable.\n\nStart with a simple implementation. Use an existing Julia package to implement the finite difference estimates for the gradient and Hessian. Think about the arguments and any defaults, as well as the type of the output. For the moment don’t set the types of the input arguments. You can start by assuming the function takes only one argument and simply returns the value at which the function is minimized.\nNow consider returning richer output. Consider using a named tuple, a dictionary, or a struct. What seem like the advantages/disadvantages? Choose one and implement it.\nSet up an array and save the progression of values along the optimization path.\n(We won’t cover this in class until Tuesday Jan. 28.) Add argument typing to your Newton function. Allow the initial value to be of any numeric type. See what the the type of the return value is for various numeric input types.\nUse a ChatBot (lmarena.ai provides free access if you don’t want to sign up for the free tier of one of the commercial services) to write the code. Compare it to your code and indicate strengths/weaknesses.\n\nDefine the matrix A = [1:4  5:8  ones(Int64,4)]. Predict the result of performing the following operations in Julia (before checking your answers by running them). Note that the lines are meant to be run one-by-one in the same workspace, so when you change an array, this will affect the subsequent statements.\n\nx = A[3,:]\nB = A[2:2,1:3]\nA[1,1] = 9 + A[2,3]\nA[1:3,2:3] = [0 0; 0 0; 0 0]\nA[1:2,2:3] = [1 3; 1 3]\ny = A[1:4, 3]\nA = [A [2 1 7; 7 4 5; ones(Int64,2,3)]]\nC = A[[1,3],2]\nD = A[[1,2,4],[1,3,4]]\n\nExperiment with some ways to extract the elements of a vector that correspond to the even indices, i.e., x[2], x[4],…\nUse array functions and vectorization to solve the problems below using only a single line of code for each problem, where A = reshape((-22:22) .% 11, 9, 5).\n\nCount the number of elements for which \\(A_{i,j}^2&lt;10\\).\nCreate a matrix containing only the columns of A where the first element \\(A_{1,j} &gt;= 0\\).\nModify A such that all elements that are even are multiplied by 3.\n\nConsider dictionaries, named tuples, and structs. Experiment with sizeof and pointer_from_objref to try to understand memory use (including any pointers) of these data structures. Next consider arrays that have homogeneous types and those with heterogeneous types.",
    "crumbs": [
      "Problem Sets",
      "Problem Set 1"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistics 244: Computing for Statistics and Data Science with Julia",
    "section": "",
    "text": "Ed\n\n  Gradescope\n\n  Tutorials\n\n  PollEV\n\n\nNo matching items",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "Statistics 244: Computing for Statistics and Data Science with Julia",
    "section": "Course description",
    "text": "Course description\nProgramming and computation for applications in statistics, data science and related fields, focusing on the use of Julia, a modern language that offers interactivity with high performance based on just-in-time compilation. The course will also cover the use of co-processors, in particular GPUs, through Julia and Python packages such as Jax and PyTorch. Topics will include data types, functional programming, multiple argument dispatch, memory use, efficiency, parallelization, robustness and testing.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#course-materials",
    "href": "index.html#course-materials",
    "title": "Statistics 244: Computing for Statistics and Data Science with Julia",
    "section": "Course materials",
    "text": "Course materials\nSee the links above for the key resources for the course.\nMost course content (in particular notes and problem sets) are available through this website via the links in the left sidebar.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#questions-about-taking-the-class",
    "href": "index.html#questions-about-taking-the-class",
    "title": "Statistics 244: Computing for Statistics and Data Science with Julia",
    "section": "Questions about taking the class",
    "text": "Questions about taking the class\nIf you would like to audit the class, enroll as a UC Berkeley undergraduate, or enroll as a concurrent enrollment student (i.e., for visiting students), or for some other reason are not enrolled, please fill out this survey as soon as possible and, ideally, chat with me before/after the first class. All those enrolled or wishing to take the class should have filled it out by Wednesday January 24 at noon.\nPlease see the syllabus for the computing background I expect.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "ps/ps2.html",
    "href": "ps/ps2.html",
    "title": "Problem Set 2",
    "section": "",
    "text": "I haven’t fully worked these problems myself, so if you run into any strange issues, please post on Ed as there could be mistakes/oversights on my part.\nPlease submit as a PDF to Gradescope.\nPlease generate the PDF using Quarto. Feel free to work in a Jupyter notebook and then convert to Quarto before rendering to PDF. Other formats that look professional and are designed for working with code and math notation may also be fine - just check with me via a public post on Ed first.\nRemember to note at the start of your document the names of any other students that you worked with on the problem set (or indicating you didn’t work with anyone if that was the case) and then indicate in the text or in code comments any specific ideas or code you borrowed from another student or any online reference (including ChatGPT or the like).\nIn general, your solution should not just be code - you should have text describing how you approached the problem and what decisions/conclusions you made, though for simple problems, this can be quite short. Your code should have comments indicating what each function or block of code does, and for any lines of code or code constructs that may be hard to understand, a comment indicating what that code does.\nYou do not need to (and should not) show exhaustive output, but in general you should show short examples of what your code does to demonstrate its functionality. The output should be produced as a result of the code chunks being run during the rendering process, not by copy-pasting of output from running the code separately (and definitely not as screenshots).\nI do not recommend writing initial answers using a ChatBot, as I think you are likely to fool yourself in terms of how much you are learning about Julia and programming concepts/skills more generally. But it’s up to you to decide how heavily to rely on a ChatBot. And refining your initial answers using a ChatBot seems like a good strategy. Using your own knowledge and information online to check the results of a ChatBot and using a ChatBot to check your own coding can both be important/useful.",
    "crumbs": [
      "Problem Sets",
      "Problem Set 2"
    ]
  },
  {
    "objectID": "ps/ps2.html#comments",
    "href": "ps/ps2.html#comments",
    "title": "Problem Set 2",
    "section": "",
    "text": "I haven’t fully worked these problems myself, so if you run into any strange issues, please post on Ed as there could be mistakes/oversights on my part.\nPlease submit as a PDF to Gradescope.\nPlease generate the PDF using Quarto. Feel free to work in a Jupyter notebook and then convert to Quarto before rendering to PDF. Other formats that look professional and are designed for working with code and math notation may also be fine - just check with me via a public post on Ed first.\nRemember to note at the start of your document the names of any other students that you worked with on the problem set (or indicating you didn’t work with anyone if that was the case) and then indicate in the text or in code comments any specific ideas or code you borrowed from another student or any online reference (including ChatGPT or the like).\nIn general, your solution should not just be code - you should have text describing how you approached the problem and what decisions/conclusions you made, though for simple problems, this can be quite short. Your code should have comments indicating what each function or block of code does, and for any lines of code or code constructs that may be hard to understand, a comment indicating what that code does.\nYou do not need to (and should not) show exhaustive output, but in general you should show short examples of what your code does to demonstrate its functionality. The output should be produced as a result of the code chunks being run during the rendering process, not by copy-pasting of output from running the code separately (and definitely not as screenshots).\nI do not recommend writing initial answers using a ChatBot, as I think you are likely to fool yourself in terms of how much you are learning about Julia and programming concepts/skills more generally. But it’s up to you to decide how heavily to rely on a ChatBot. And refining your initial answers using a ChatBot seems like a good strategy. Using your own knowledge and information online to check the results of a ChatBot and using a ChatBot to check your own coding can both be important/useful.",
    "crumbs": [
      "Problem Sets",
      "Problem Set 2"
    ]
  },
  {
    "objectID": "ps/ps2.html#problems",
    "href": "ps/ps2.html#problems",
    "title": "Problem Set 2",
    "section": "Problems",
    "text": "Problems\n\nWrite a function that sums the elements of a dictionary, but only if the values are all integer or floating point scalar numbers, handled by setting the type of the argument (i.e., a Dictionary with types specified for the keys and values). Hint: you will need to use the &lt;: syntax. The keys can be any type.\n\nNow add a function with the same name that concatenates strings or character literals as the values.\n\nEnhance your Newton function to allow the objective function to take arbitrary additional arguments, passed along from your function into the objective function.\nLet’s robustify our Newton method. Add error trapping using Julia’s exception system. This should catch divergence as well as convergence to a local maximum. Add useful messaging with @info, @warn, @error. Also handle the following situations: (1) when the next value has a higher value than the current value (use backtracking) and (2) when the next value is outside the range of the previous values (use bisection).\nSet up a few tests for your Newton function using Julia’s testing framework.\n\nTip: Here’s a gradient function (written in Python) where Newton’s method can diverge from some starting points:\ndef fp(x, theta=1): ## First derivative - we want the root of this. return np.exp(x * theta) / (1 + np.exp(x * theta)) - 0.5\n\nWrite a function constructor that creates a version of a function that reports how many times it has been called. Ideally this would work regardless of how many (if any) positional or keyword arguments are used by the function. Additionally, try to manipulate kwargs so that the wrapper only reports the number of times run when the wrapped function is called as myfun(_report=true).\n\nIf you want a real challenge, try to do this using a macro. I was able to do this using some meta programming (code manipulation) tools in Julia but it took some Googling and experimentation and it was helpful that I had some experience with meta programming in R.\n\nConsider this overdispersed binomial likelihood calculation. [Show latex for the function] Write using looping and using vectorization and compare speed. Do the calculation inside and outside a function. Assess the time for the JIT compilation. The following is an inefficient vectorized calculation in Python. Convert it to Julia and improve it before comparing to a non-vectorized version.\n\nnormConstVecNaive &lt;- function(n, p, phi) { k &lt;- 0:n loglik &lt;- lchoose(n, k) klogk &lt;- klog(k) klogk[is.nan(klogk)] &lt;- 0 nmklognmk &lt;- (n-k)log((n-k)) nmklognmk[is.nan(nmklognmk)] &lt;- 0 logLik &lt;- lchoose(n, k) + klogk + nmklognmk - nlog(n) + phi(nlog(n) - klogk - nmklognmk) + kphilog(p) + (n - k)phi*log(1-p) return(sum(exp(logLik))) } out2 &lt;- normConstVecNaive(n, p, phi)",
    "crumbs": [
      "Problem Sets",
      "Problem Set 2"
    ]
  },
  {
    "objectID": "office_hours.html",
    "href": "office_hours.html",
    "title": "Office hours",
    "section": "",
    "text": "Chris (Evans 495 or Zoom (make sure to email me in advance to use Zoom)\n\nTuesday 2-3 pm\nWednesday 3-4 pm\nThursday 2:30-3:30 pm\nBy appointment\nFeel free to drop by if my door is open, though I won’t always be able to help at the time.",
    "crumbs": [
      "Office Hours"
    ]
  },
  {
    "objectID": "howtos/useQuarto.html",
    "href": "howtos/useQuarto.html",
    "title": "Using Quarto",
    "section": "",
    "text": "Quarto is a system for publishing technical content. We’ll use with source files written in the Quarto flavor of Markdown, which can include mathematical notation using LaTeX syntax and code chunks that are evaluated during the publishing process. One then “renders” the source file into either HTML or PDF.",
    "crumbs": [
      "How tos",
      "Using Quarto"
    ]
  },
  {
    "objectID": "howtos/useQuarto.html#installing-and-using-quarto",
    "href": "howtos/useQuarto.html#installing-and-using-quarto",
    "title": "Using Quarto",
    "section": "Installing and using Quarto",
    "text": "Installing and using Quarto\nUnless you plan to generate your problem set solutions on the SCF, you’ll need to install Quarto.\nOnce installed, you should be able to run commands such as quarto render FILE and quarto preview FILE from the command line.\nTo render to PDF, you’ll need a LaTeX engine installed. A good minimal solution if don’t already have LaTeX installed (e.g., via MicTeX in Windows or MacTeX on MacOS) is to install tinytex: quarto install tinytex.\nQuarto also runs from the Windows Command shell or PowerShell.\nquarto convert converts back and forth between the Jupyter notebook (.ipynb) and Quarto Markdown (.qmd) formats. So if you prefer, you can develop in a notebook and then convert to qmd and then render to prepare a nice-looking PDF for problem set/project/presentation submission.\nThe Quarto manual has more details on using Quarto specifically in the context of using Julia.\n\nExample Quarto document\nHere’s example content of a Quarto document. The first part is the YAML header/metadata giving details of how the document should be processed.\n---\ntitle: \"Problem Set 1 Solutions\"\nauthor: \"Chris Paciorek\"\ndate: \"2025-01-21\"\nengine: jupyter\n---\n\nHere's some math: $\\int \\pi(\\theta)d\\theta = 1$.\n\nHere's a code chunk that is evaluated.\n\n```{julia}\nx = 3;\nprintln(\"The result is $(x*7).\")\n```\nMore details are available in the Quarto manual, including options for controlling the output from code chunks.\n\n\nRendering engines\nBy default, Quarto uses Jupyter to process code chunks. (Note that engine: jupyter is specified above in the metadata but is not needed.)\nThere are other rendering engines one can use to process the code chunks, with various advantages and disadvantages.\n\nJupyter engine\nThe Jupyter engine requires that the IJulia kernel installed – see the howto on accessing Julia.\nTo use a specific kernel, you can replace engine: jupyter with jupyter: &lt;kernelname&gt;, where &lt;kernelname&gt; is the name of the Jupyter kernel to be used. On the SCF, this could be jupyter: julia-1.10 as there is a kernel named julia-1.10.\nSome downsides of this engine are:\n\nAll output from a chunk is printed after the chunk rather than immediately after the line of code causing the output.\nOnly the output from the last line of code in a chunk is printed out (except if print() is used explicitly).\n\n\n\nJulia engine\nThere is also now a Julia engine for Quarto. To use it, simply have engine: julia in the metadata.\nThe rendering uses the QuartoNotebookRunner.jl package. It will supposedly install it in an isolated way, and that worked on my laptop, but I had package version incompatibilities on the SCF.\nSome downsides of this engine, as with the Jupyter engine, are:\n\nAll output from a chunk is printed after the chunk rather than immediately after the line of code causing the output.\nOnly the output from the last line of code in a chunk is printed out (except if print() is used explicitly).\n\n\n\nKnitr engine (via R)\nThe knitr engine requires that you have R installed on your computer, with the rmarkdown R package installed.\nTo use it, simply have engine: knitr in the metadata.\nSome upsides of this engine involve having the output from the code chunks print out nicely:\n\nOutput from a chunk is interspersed with the line of code creating the output.\nOutput from all lines is printed out.\n\nHowever, I have had some difficulties with the knitr engine, including\n\nErrors when trying to have plots included in the output.\nHaving output from simply invoking an object name (e.g., x rather than print(x)) sometimes appear in the terminal/console rather than in the rendered document.\nThe #| error: true chunk execution option does not seem to work (I’ve filed a bug report about this.).",
    "crumbs": [
      "How tos",
      "Using Quarto"
    ]
  },
  {
    "objectID": "howtos/installPython.html",
    "href": "howtos/installPython.html",
    "title": "Installing Python",
    "section": "",
    "text": "The focus of the course is Julia, but I plan to spend a small amount of time on the use of GPUs via Python. You can use Python through the SCF (and you’ll need to do so for GPU access), but if you do want install Python on your own machine, here is some information\nWe recommend using the Miniforge distribution as your Python 3.12 installation.\nOnce you’ve installed Python, please install the following packages:\n\nnumpy\nscipy\npandas\njax\npytorch\n\nAssuming you installed Miniforge, you should be able to do this from the command line:\nconda install -c conda-forge numpy scipy pandas jax\nconda install pytorch torchvision torchaudio pytorch-cuda=12.4 -c pytorch -c nvidia",
    "crumbs": [
      "How tos",
      "Installing Python"
    ]
  },
  {
    "objectID": "howtos/accessSCF.html",
    "href": "howtos/accessSCF.html",
    "title": "Accessing the SCF",
    "section": "",
    "text": "The SCF is the Statistical Computing Facility, which provides computational resources for the Department of Statistics.\nFor our purposes, the SCF provides access to all the software and resources we will need for class. For much of what we do, it will serve as an alternative to your laptop if you run into problems. For GPU work and for some of the parallelization work it will be the primary resource.",
    "crumbs": [
      "How tos",
      "Accessing the SCF"
    ]
  },
  {
    "objectID": "howtos/accessSCF.html#get-an-scf-account",
    "href": "howtos/accessSCF.html#get-an-scf-account",
    "title": "Accessing the SCF",
    "section": "Get an SCF account",
    "text": "Get an SCF account\nIf you don’t already have an account, please request one, indicating you are a student in Statistics 244.",
    "crumbs": [
      "How tos",
      "Accessing the SCF"
    ]
  },
  {
    "objectID": "howtos/accessSCF.html#access-to-the-statistical-computing-facility-scf",
    "href": "howtos/accessSCF.html#access-to-the-statistical-computing-facility-scf",
    "title": "Accessing the SCF",
    "section": "Access to the Statistical Computing Facility (SCF)",
    "text": "Access to the Statistical Computing Facility (SCF)\nThere are two main ways to access the SCF machines.\n\nYou can login to our various Linux servers and access a terminal/bash shell that way. Please see http://statistics.berkeley.edu/computing/access.\nThe SCF JupyterHub provides browser-based access to a terminal/bash shell, Jupyter notebooks, and more. From a Jupyter notebook, you can select to use Julia as the kernel (the language used for processing code cells).",
    "crumbs": [
      "How tos",
      "Accessing the SCF"
    ]
  },
  {
    "objectID": "howtos/accessSCF.html#software",
    "href": "howtos/accessSCF.html#software",
    "title": "Accessing the SCF",
    "section": "Software",
    "text": "Software\nJulia (possibly not with all needed packages at the moment), Python (with all needed packages), Git, and Quarto are all available from any SCF machine.",
    "crumbs": [
      "How tos",
      "Accessing the SCF"
    ]
  },
  {
    "objectID": "notes/notes3.html",
    "href": "notes/notes3.html",
    "title": "Notes 3: Types and dispatch",
    "section": "",
    "text": "This document is the third of a set of notes, this document focusing on types and method dispatch based on types. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader.",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes3.html#introduction",
    "href": "notes/notes3.html#introduction",
    "title": "Notes 3: Types and dispatch",
    "section": "",
    "text": "This document is the third of a set of notes, this document focusing on types and method dispatch based on types. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader.",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes3.html#composite-types-structs",
    "href": "notes/notes3.html#composite-types-structs",
    "title": "Notes 3: Types and dispatch",
    "section": "Composite types (structs)",
    "text": "Composite types (structs)\nA struct is a collection of named fields, useful for holding information of a particular structure.\nHere’s a struct meant to contain information about a Gaussian process, with each element in the type also having its own declared type (though that is not required).\nObjects of the type are constructed by calling the name of the type with the field values, in order.\n\nstruct GaussianProcess\n  x::Vector\n  covFun::Function\n  params\nend\n\nfunction expCov(dists, params)\n   return params[2]*exp.(-dists / params[1])\nend\n\nmyGP = GaussianProcess([0:0.01:1;], expCov, (1, .5));\nmyGP.params\n\n(1, 0.5)\n\n\nIt appears one has to know the exact order of the inputs to the constructor and give them by position rather than by name.\n\n\n\n\n\n\nNaming of types\n\n\n\nType names (including structs) are generally capitalized. One nice thing is that it helps distinguish constructors (e.g., GaussianProcess) from regular functions.\n\n\n\nStruct constructors\nWe can create an explicit (outer) constructor that gives some flexibility in terms of what inputs the user can provide.\n\nfunction ExpGaussianProcess(x, params)\n   GaussianProcess(x, expCov, params)\nend\n\nmyGP = ExpGaussianProcess([0:0.01:1;], (1, .5));\n\nWe can use an inner constructor to check inputs. This is a bad example because by defining types for the variables (as seen in the original definition of the GaussianProcess struct), this can be handled automatically by Julia.\n\nstruct GaussianProcess2\n  x\n  covFun\n  params\n  ## Define the constructor using function creation shorthand and if-else shorthand:\n  GaussianProcess2(x, covFun, params) = isa(covFun, Function) ?\n                   new(x, covFun, params) : error(\"covFun needs to be a function\")\nend\n\nmyGP = GaussianProcess2([0:0.01:1;], expCov, (1, .5));\n\nmyGP = GaussianProcess2([0:0.01:1;], 3, (1, .5))\n\nLoadError: covFun needs to be a function\ncovFun needs to be a function\n\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] GaussianProcess2(x::Vector{Float64}, covFun::Int64, params::Tuple{Int64, Float64})\n   @ Main ./In[4]:6\n [3] top-level scope\n   @ In[4]:12\n\n\n\n\n\n\n\n\nTypes can’t be redefined\n\n\n\nWe can’t redefine a struct (hence my use of GaussianProcess2 above). I think this has to do with the fact that this would break methods that have been specialized to the type.",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes3.html#type-declarations",
    "href": "notes/notes3.html#type-declarations",
    "title": "Notes 3: Types and dispatch",
    "section": "Type declarations",
    "text": "Type declarations\nType declarations are a good and easy way to make our code robust without including a bunch of manual assertions.",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes3.html#type-declarations-for-functions",
    "href": "notes/notes3.html#type-declarations-for-functions",
    "title": "Notes 3: Types and dispatch",
    "section": "Type declarations for functions",
    "text": "Type declarations for functions\nWe can declare types for function arguments.\n\nfunction mysum(x::Float64, y::Float64)\n  return x+y\nend\n\nmysum(3.5, 4.8)\n\n8.3\n\n\n\nmysum(3, 4.8)\n\n\nMethodError: no method matching mysum(::Int64, ::Float64)\n\nClosest candidates are:\n  mysum(::Float64, ::Float64)\n   @ Main In[5]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[6]:1\n\n\n\n\nmysum(\"hello\", 4.8)\n\n\nMethodError: no method matching mysum(::String, ::Float64)\n\nClosest candidates are:\n  mysum(::Float64, ::Float64)\n   @ Main In[5]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[7]:1\n\n\n\n\nType declarations with structs\n\nusing Random, Distributions, LinearAlgebra, Plots\n\nfunction simulate(gp::GaussianProcess)\n  n = length(gp.x)\n  dists = abs.(gp.x .- gp.x')\n  cov = gp.covFun(dists, gp.params)\n  L = cholesky(cov).L\n  y = L * rand(Normal(), n)\n  return y\nend\n\nRandom.seed!(123)\nmyGP = GaussianProcess([0:0.01:1;], expCov, (1, .5));\nf = simulate(myGP);\n\n\nplot(myGP.x, f)   \n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntmp = simulate(7) \n\n\nMethodError: no method matching simulate(::Int64)\n\nClosest candidates are:\n  simulate(::GaussianProcess)\n   @ Main In[8]:3\n\n\nStacktrace:\n [1] top-level scope\n   @ In[10]:1\n\n\n\n\n\nType unions and abstract types\n\nIntOrFloat = Union{Float16, Float32, Float64, Int16, Int32, Int64}\nfunction mysum(x::IntOrFloat, y::IntOrFloat)\n  return x+y\nend\n\nmysum(3.5, 4.8)\n\n8.3\n\n\n\nmysum(3, 4.8)\n\n7.8\n\n\n\ntypeof(mysum(3, 4))\n\nInt64\n\n\n\nmysum(\"hello\", 4.8)\n\n\nMethodError: no method matching mysum(::String, ::Float64)\n\nClosest candidates are:\n  mysum(::Float64, ::Float64)\n   @ Main In[5]:1\n  mysum(::Union{Float16, Float32, Float64, Int16, Int32, Int64}, ::Union{Float16, Float32, Float64, Int16, Int32, Int64})\n   @ Main In[11]:2\n\n\nStacktrace:\n [1] top-level scope\n   @ In[14]:1\n\n\n\nAlternatively (and better as it’s provided as part of the language), there is already a abstract type of ints and floats. Abstract types help with having a hierarchy of types (more later).\n\nfunction mysum(x::Real, y::Real)\n  return x+y\nend\n\nmysum(3.5, 4.8)\n\n8.3\n\n\n\nmysum(3, 4.8)\n\n7.8\n\n\n\nmysum(3, 4)\n\n7\n\n\n\ntypeof(mysum(3, 4))\n\nInt64\n\n\n\nmysum(\"hello\", 4.8)\n\n\nMethodError: no method matching mysum(::String, ::Float64)\n\nClosest candidates are:\n  mysum(::Float64, ::Float64)\n   @ Main In[5]:1\n  mysum(::Union{Float16, Float32, Float64, Int16, Int32, Int64}, ::Union{Float16, Float32, Float64, Int16, Int32, Int64})\n   @ Main In[11]:2\n  mysum(::Real, ::Real)\n   @ Main In[15]:1\n\n\nStacktrace:\n [1] top-level scope\n   @ In[19]:1\n\n\n\n\n\nType declarations for function output\n\nfunction mysum2(x::Real, y::Real)::Float64\n  return x+y\nend\n\ntypeof(mysum2(3, 4))\n\nFloat64\n\n\nWhat do you think this will happen if we do this?\n\nfunction mysum3(x::Real, y::Real)::String\n  return x+y\nend\n\nmysum3(3, 4)\n\n\n\nTypes in arrays\nWe’ve already seen that one can create arrays of heterogeneous elements, but one can’t modify a homogeneous array in a way that would make it heterogeneous.\n\n\n\n\n\n\nExercise\n\n\n\n\nExperiment with arrays that contain missing values (via missing). What happens with computations?\nWhat seems to be the difference between missing and nothing?\n\n\n\n\n\nMore on structs and constructors\nHere’s a slightly more involved example of a struct that ties together some of what we’ve seen so far. (For use later on, we’ll make it a mutable struct so we can modify the struct elements.)\n\nmutable struct Person\n  name::String\n  age::Real\n  function Person(name::String, age::Real)\n    @assert(age &lt; 130, \"Age exceeds human lifespan.\")\n    new(name, age)\n  end\nend\n\nbiden = Person(\"Joe Biden\", 82)\n\nPerson(\"Joe Biden\", 82)\n\n\nThese invocations will both fail.\n\nlincoln = Person(\"Abraham Lincoln\", \"hello\")\n\n\nMethodError: no method matching Person(::String, ::String)\n\nClosest candidates are:\n  Person(::String, ::Real)\n   @ Main In[21]:4\n\n\nStacktrace:\n [1] top-level scope\n   @ In[22]:1\n\n\n\n\nlincoln = Person(\"Abraham Lincoln\", 200)\n\nLoadError: AssertionError: Age exceeds human lifespan.\nAssertionError: Age exceeds human lifespan.\n\nStacktrace:\n [1] Person(name::String, age::Int64)\n   @ Main ./In[21]:5\n [2] top-level scope\n   @ In[23]:1",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes3.html#multiple-dispatch",
    "href": "notes/notes3.html#multiple-dispatch",
    "title": "Notes 3: Types and dispatch",
    "section": "Multiple dispatch",
    "text": "Multiple dispatch\nWe can define different versions of functions or operators (these are called methods) that are used depending on the input types.\n\nFunctions and methods\nThe first time we define a method, it creates the generic function and initial method. When we define further methods, they are added to the existing function.\n\nfunction test(x)\n  println(\"In test, called with arbitrary input: \", x)\nend\n\nfunction test(x::String)\n  println(\"In test, called with a string: \", x)\nend\n\ntest(7)\n\nIn test, called with arbitrary input: 7\n\n\n\ntest(\"hello\")\n\nIn test, called with a string: hello\n\n\nIt’s called multiple dispatch because the dispatching can depend on multiple arguments and not just the first, which is not generally the case in other languages.\n\n\nOperator overloading is multiple dispatch\nMultiple dispatch is basically what is called “overloading” in other languages.\nLet’s illustrate multiple dispatch with our mutable Person struct.\n\nimport Base.+\n\nfunction +(person::Person, incr::Real)\n  person.age += incr\n  return person\nend\n\nbarack = Person(\"Barack Obama\", 60)\nbarack + 3;\nbarack\n\nPerson(\"Barack Obama\", 63)\n\n\nNow we’ll set up another + method for adding two Persons.\n\nstruct Partnership\n  person1::Person\n  person2::Person\n  year_formed::Int\nend\n\nfunction +(personA::Person, personB::Person)::Partnership\n  return Partnership(personA, personB, 1990)\nend\n\nmichelle = Person(\"Michelle Obama\", 60)\n\nobamas = barack + michelle\n\nPartnership(Person(\"Barack Obama\", 63), Person(\"Michelle Obama\", 60), 1990)\n\n\nThat’s a decent illustration of the power of multiple dispatch but it’s awkward to hard-code in the “1990” in this case. If we were using multiple dispatch with a function, then we wouldn’t be restricted to having two arguments.\nWe’ve now added a couple more + methods to the large number already existing in Julia’s Base module/library.\nNote the similarity to object-oriented programming, but the methods are not part of classes.\n\n\n\n\n\n\nExtensibility\n\n\n\nThis an example of extensibility. Julia’s core functionality will work with user-defined objects.\n\n\n\n\nShow methods\nThe same idea extends to other core Julia functions/functionality, such as printing objects.\nHere we’ll overload the Base show function. Before we do so, let’s see what existing show methods there are:\n\nBase.show\n# methods(Base.show)\n\nprint(myGP)\n\nfunction Base.show(io::IO, gp::GaussianProcess)\n  println(\"A Gaussian process defined on a grid from $(gp.x[1]) to $(gp.x[end]).\")\nend\n\nprint(myGP)\nmyGP  \n\nGaussianProcess([0.0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.8, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.9, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.0], expCov, (1, 0.5))A Gaussian process defined on a grid from 0.0 to 1.0.\n\n\n\n\n\nA Gaussian process defined on a grid from 0.0 to 1.0.\n\n\nThis is similar to combining the __str__ and __repr__ “dunder” (double underscore) methods for Python classes.",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes3.html#subtyping",
    "href": "notes/notes3.html#subtyping",
    "title": "Notes 3: Types and dispatch",
    "section": "Subtyping",
    "text": "Subtyping\nTypes can relate to each other. Generally in Julia one groups types as subtypes of an abstract type whose purpose is to relate the subtypes. This is similar to class inheritance in object-oriented programming.\n\nabstract type GeneralPerson end\n\nmutable struct President &lt;: GeneralPerson\n    name::String\n    age::Real\n    inauguration_year::Int64\nend\n\nmutable struct Employee &lt;: GeneralPerson\n    name::String\n    age::Real\n    employer::String\nend\n\nThe benefit is that we can define a single function/operator that works with multiple subtypes.\n\n# These will work with both Employee and President\nfunction +(person::GeneralPerson, incr::Real)\n  person.age += incr\n  return person\nend\n\nfunction Base.show(io::IO, person::GeneralPerson)\n  println(\"A person of age $(person.age).\")\nend\n\nmacron = President(\"Emmanuel Macron\", 48, 2017)\n\n\n\n\nA person of age 48.\n\n\n\nmacron + 1\n\n\n\n\nA person of age 49.\n\n\nWell that worked as an illustration, but in this case it’s not clear that macron is a special kind of person based on the printout. So we probably would want special show methods for the concrete types.\n\nAbstract types vs. concrete types\nThe purpose of abstract types is to organize types into a hierarchy. In principle, one doesn’t create instances of an abstract type (hence “abstract”), only of a concrete type, and yet, one can do Real(4) and Number(4), even though those are abstract types, so I’m not fully understanding something here.\n\n\nType ordering\nWe can check if a type is a subtype like this:\n\nInt64 &lt;: Real\n\ntrue\n\n\n\nReal &lt;: Number\n\ntrue\n\n\n\nNumber &lt;: Any\n\ntrue\n\n\n\nEmployee &lt;: GeneralPerson\n\ntrue\n\n\n\nEmployee &lt;: Float64\n\nfalse\n\n\n\nGeneralPerson &gt;: Employee\n\ntrue\n\n\n\n\n\n\n\n\nUse of :\n\n\n\nNote that : appears in various ways related to Julia code structure:\n\nx::Real        # type declaration\nInt64 &lt;: Real  # type hierarchy\n:x             # representing a variable as code in meta programming\n\n\n\n\n\nNested subtypes\nOne can’t have subtypes of non-abstract (concrete) types.\nHere’s what the Julia manual has to say: “It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages.”\nSo the idea seems to be that there’s not much point to having one type that inherits the fields (structure) of another type. Though I’m not sure what the difficulties are in inheriting both.\n\nmutable struct Electrician &lt;: Employee\n    name::String\n    age::Real\n    employer::String\n    times_electrocuted::Int\nend\n\nLoadError: invalid subtyping in definition of Electrician: can only subtype abstract types.\ninvalid subtyping in definition of Electrician: can only subtype abstract types.\n\nStacktrace:\n [1] top-level scope\n   @ In[38]:1\n\n\n\n\nParametric types\nThere’s even more flexibility in terms of types, if we parameterize types.\nWe can use T as a parametric type that accommodates various types (in this case only numeric ones).\nThis is not a particularly realistic example, but it enforces that both the age and inauguration_year have the same numeric type.\n\nmutable struct USPresident{T &lt;: Real} &lt;: GeneralPerson\n    name::String\n    age::T\n    inauguration_year::T\nend\n\nUSPresident(\"Grant\", 125, 1868)\n\n\n\n\nA person of age 125.\n\n\n\nUSPresident(\"Grant\", 125.3, 1868.0)\n\n\n\n\nA person of age 125.3.\n\n\n\nUSPresident(\"Grant\", 125.3, 1868);\n\n\nMethodError: no method matching USPresident(::String, ::Float64, ::Int64)\n\nClosest candidates are:\n  USPresident(::String, ::T, ::T) where T&lt;:Real\n   @ Main In[39]:2\n\n\nStacktrace:\n [1] top-level scope\n   @ In[41]:1",
    "crumbs": [
      "Course Notes",
      "Notes 3: Types and dispatch"
    ]
  },
  {
    "objectID": "notes/notes1.html",
    "href": "notes/notes1.html",
    "title": "Notes 1: Introduction",
    "section": "",
    "text": "This document is the first of a set of notes. It gives an overview of key syntax, tools, and concepts for using Julia. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader.\nThis document covers basic syntax, basic types, data structures, and functions. For more information, Think Julia Chapters 1-12 is a good reference.",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#introduction",
    "href": "notes/notes1.html#introduction",
    "title": "Notes 1: Introduction",
    "section": "",
    "text": "This document is the first of a set of notes. It gives an overview of key syntax, tools, and concepts for using Julia. The notes are not meant to be particularly complete in terms of useful functions (Google and LLMs can now provide that quite well), but rather to introduce the language and consider key programming concepts in the context of Julia.\nGiven that, the document heavily relies on demos, with interpretation in some cases left to the reader.\nThis document covers basic syntax, basic types, data structures, and functions. For more information, Think Julia Chapters 1-12 is a good reference.",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#variables-and-types",
    "href": "notes/notes1.html#variables-and-types",
    "title": "Notes 1: Introduction",
    "section": "Variables and types",
    "text": "Variables and types\n\nBasic types\nLet’s start by defining some variables and seeing what their types are.\n\ntypeof(2)\n\nInt64\n\nx = 2.0\n\n2.0\n\ntypeof(x)\n\nFloat64\n\ns = \"hello\"\n\n\"hello\"\n\ntypeof(s)\n\nString\n\ntypeof(s[1])\n\nChar\n\ntypeof('\\n')\n\nChar\n\n## Unicode characters\n'h'\n\n'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)\n\n'i'\n\n'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n\n'\\n'\n\n'\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n\n'θ'\n\n'θ': Unicode U+03B8 (category Ll: Letter, lowercase)\n\n\ny = (3, 7.5)\n\n(3, 7.5)\n\ntypeof(y)\n\nTuple{Int64, Float64}\n\n\nAs we’ll be discussing more, knowing what type a variable is (particularly for large objects such as large arrays) is important for thinking about memory use, what methods work with what types of variables, and when variables need to be cast/coerced to a different type.\n\n\n\n\n\n\nWarning\n\n\n\nThe Unicode/LaTeX characters may not show up in the PDF version of this document.\n\n\nWe can enter LaTeX characters/formatting by typing in LaTeX syntax (starting with a \\) and then TAB.\n\nθ = 3.57  # \\theta TAB\n\n3.57\n\n\n#=\nNote the use of a comment\nin the initial line.\n\nAnd this here is a multi-line comment.\n=#\n\nx₁ = 7  # x\\_1 TAB\n\n7\n\n\n# Try \\theta TAB \\bar TAB = 7 (it works in some contexts).\n\n水=5\n\n5\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nDo you like the idea of using non-ASCII characters for variable names?\n\n\n\n\nA bit about strings\n\nx = 'hello'\n\nx = \"hello\"\nx[1] = \"a\"\n\n\n\nCasting/coercing between types\n\nstring(32)\n\n\"32\"\n\nparse(Float64, \"32.5\")\n\n32.5\n\n\nSome languages (such as R) will often cast between types behind the scenes. With Julia, one is often more deliberate about types as we’ll see.\n\n\nMore on types and comparisons\n\nx = 3\n\n3\n\ny = 3.0\n\n3.0\n\nx == y\n\ntrue\n\nx ≠ y\n\nfalse\n\nx &gt; y\n\nfalse\n\nx &gt; y || x &lt;= y\n\ntrue\n\n\nisa(x, Int)\n\ntrue\n\ny isa Int\n\nfalse\n\ny isa Number\n\ntrue\n\n\n'a' ∈ \"banana\"  # \\in TAB\n\ntrue\n\n'a' ∉ \"banana\"  # \\notin TAB\n\nfalse\n\n\naString = \"a\"\n\n\"a\"\n\n'a' == aString\n\nfalse\n\n'a' == aString[1]\n\ntrue\n\n\n\n\nConditional (if-else) statements\n\nif x &lt; y\n    println(\"x is less than y\")\nelseif x &gt; y\n    println(\"x is greater than y\")\nelse\n    println(\"x and y are equal\")\nend\n\nx and y are equal\n\n\n\n\nPrinting and string interpolation\nWe can use variables in print statements in various ways.\n\nperson = \"Alice\"\n\n\"Alice\"\n\n\nperson = \"Alice\";\n\n\"Hello, $(person) with name of length $(length(person)).\"\n\n\"Hello, Alice with name of length 5.\"\n\n\nprintln(\"Hello, \", person, \" with name of length \", length(person), \".\")\n\nHello, Alice with name of length 5.\n\nprintln(\"Hello, $(person) with name of length $(length(person)).\")\n\nHello, Alice with name of length 5.\n\nprintln(\"Hello, \" * person * \" with name of length \" * string(length(person)) * \".\")\n\nHello, Alice with name of length 5.",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#functions-and-operators",
    "href": "notes/notes1.html#functions-and-operators",
    "title": "Notes 1: Introduction",
    "section": "Functions and operators",
    "text": "Functions and operators\n\nOperators (and not just for math/booleans)\n\nvalue = 7;\nvalue *= 3;\nvalue\n\n21\n\n\n\nValue\n\nERROR: UndefVarError: `Value` not defined\n\nx = 3\n\n3\n\ntmp = 7x   # Unlike any other language I know!\n\n21\n\n\ns * \" there\"\n\n\"hello there\"\n\n\ns^4\n\n\"hellohellohellohello\"\n\n\n\n\nGetting help on functions\nType ? to get into help mode, then the name of the function you want help on.\nTo see all the functions/operators available in base Julia, type “Base.” and hit tab.\n\n\nFunction definitions\n\nfunction plus3(x=0)\n  return 3+x\nend\n\nplus3 (generic function with 2 methods)\n\n\nplus3(5)\n\n8\n\n\nWhy are there two methods?\n\nmethods(plus3)\nmethods(+)\n\n\n\nVectorized use\nTo use a function (or operator) in a vectorized way, we (with exceptions) need to use the dot notation.\n\ny = [5.3, 2.5];\n\n\ny + 3\nplus3(y)\n\nERROR: MethodError: no method matching +(::Vector{Float64}, ::Int64)\nFor element-wise addition, use broadcasting with dot syntax: array .+ scalar\n\ny .+ 3\n\n2-element Vector{Float64}:\n 8.3\n 5.5\n\nplus3.(y)\n\n2-element Vector{Float64}:\n 8.3\n 5.5\n\n\n\n## Apparently no general \"recycling\"/broadcasting.\nx = [2.1, 3.1, 5.3, 7.9]\nx .+ [0., 100.]\n\nERROR: DimensionMismatch: arrays could not be broadcast to a common size; got a dimension with lengths 4 and 2\n\n\nPositional and keyword arguments\nPositional arguments (which are matched based on the order they are given) are specified before keyword arguments.\n\nfunction norm(x, p; verbose, extra)\n  if verbose  # We'll see that \"logging\" is a better way to do this.\n     println(\"Executing $(p)-norm.\")\n  end\n  if !isfinite(p) && p &gt; 0\n    return maximum(abs.(x))\n  end \n  return sum(x .^ p)^(1/p)\nend\n\nz = [3.3, 4.7, -2.2]\n\nnorm(z, 2, verbose=false, extra=0)\nnorm(z, 2; verbose=false, extra=0)\nnorm(z, 2, false, 0)\nnorm(z, p=1; verbose=false, extra=0)\nnorm(z, 1, extra=0, verbose=false)\n\nArguments can have defaults:\n\nfunction norm(x, p=2; verbose=false)\n  if verbose  # We'll see that \"logging\" is a better way to do this.\n     println(\"Executing $(p)-norm.\")\n  end\n  return sum(x .^ p)^(1/p)\nend\n\nnorm (generic function with 2 methods)\n\n\n\n\n\n\n\n\nExercise\n\n\n\nTry out various argument orders and giving or not giving names or values to the arguments and try to figure out the syntax rules of how Julia behaves. Think about how they are similar/different to your primary language and whether you like the syntax rules.\n\n\nKeyword arguments are generally used for controlling function behavior rather than as core inputs. They are not involved in multiple dispatch (more later).\nLet’s try asking a ChatBot to write a norm function in Julia.\n\n\n\n\n\n\nExercise\n\n\n\nWrite a function that implements the gamma density, \\[ f(x) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} x^{\\alpha-1} \\exp(-\\beta x), \\] for shape \\(\\alpha\\) and rate \\(\\beta\\) or scale \\(1/\\beta\\), with \\(x&gt;0, \\alpha&gt;0, \\beta&gt;0\\). Allow it to handle either the rate or scale parameterization and to return either the density or log density. Check that it works in a vectorized way for the random variable value and the parameters. Compare what you wrote to what a ChatBot gives.\n\n\n\n\nShorthand function definitions\nThese can be handy, but as a newcomer to Julia, I find them a bit hard to read.\n\nplus3a(x=1) = 3+x\n\nplus3b = (x=1) -&gt; 3+x\n\n# An anonymous function (useful for maps, functional programming).\n((x) -&gt; 3+x)\n\n((x) -&gt; 3+x)(7)",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#arrays-and-subsetting",
    "href": "notes/notes1.html#arrays-and-subsetting",
    "title": "Notes 1: Introduction",
    "section": "Arrays and subsetting",
    "text": "Arrays and subsetting\n\nSequences (and slicing)\n\nsome_text = \"This is the Greek θ\"\n\n\"This is the Greek θ\"\n\nsome_text[1]\n\n'T': ASCII/Unicode U+0054 (category Lu: Letter, uppercase)\n\nsome_text[19]\n\n'θ': Unicode U+03B8 (category Ll: Letter, lowercase)\n\nsome_text[1:4]\n\n\"This\"\n\nsome_text[17:end]\n\n\"k θ\"\n\n\n\ny = [1.1, 2.1, 3.2, 4.3, 5.7]\n\n5-element Vector{Float64}:\n 1.1\n 2.1\n 3.2\n 4.3\n 5.7\n\nprintln(y)               # Original vector\n\n[1.1, 2.1, 3.2, 4.3, 5.7]\n\n\n# Slicing by index sequence:\n\nprintln(y[1:3])          # First 3 elements\n\n[1.1, 2.1, 3.2]\n\nprintln(y[1:2:4])        # All odd-numbered elements\n\n[1.1, 3.2]\n\nprintln(y[end:-1:2])     # From end back to second element in reverse\n\n[5.7, 4.3, 3.2, 2.1]\n\nprintln(y[4:3])          # Empty subset\n\nFloat64[]\n\nz = y[:]                 # All elements (copy (not alias) of original vector)\n\n5-element Vector{Float64}:\n 1.1\n 2.1\n 3.2\n 4.3\n 5.7\n\n\n# Slicing by arbitrary index vector\nprintln(y[[4,2,4,3,3,4,4]])  # Slice by index\n\n[4.3, 2.1, 4.3, 3.2, 3.2, 4.3, 4.3]\n\n\n# Slicing by boolean array\ny[[true,false,true,false,true]]   # Slice by boolean array\n\n3-element Vector{Float64}:\n 1.1\n 3.2\n 5.7\n\n\n\n\n\n\n\n\nExercise\n\n\n\nExperiment more with slicing/indexing to make sure you get it, and what errors can occur. (As an example what happens if you index beyond the extent of the object?) See also Problems 2 and 3 on PS1.\n\n\nNote that the discussion of fruits[len] in Section 7 of Think Julia is incorrect.\n\n\nArrays (i.e., lists)\n\nx = [\"spam\", 2.0, 5, Missing, [10, 20], NaN]\n\n6-element Vector{Any}:\n    \"spam\"\n   2.0\n   5\n    Missing\n    [10, 20]\n NaN\n\nlength(x)\n\n6\n\n\ntypeof(x)\n\nVector{Any} (alias for Array{Any, 1})\n\ny = [10, 20, 30, 40]\n\n4-element Vector{Int64}:\n 10\n 20\n 30\n 40\n\ntypeof(y)\n\nVector{Int64} (alias for Array{Int64, 1})\n\nx[1] = 3.3\n\n3.3\n\nx[4] = 2.7\n\n2.7\n\ntypeof(x)   # Mutable, but type doesn't change.\n\nVector{Any} (alias for Array{Any, 1})\n\n\n\n\n\n\n\n\nMath with arrays\n\n\n\nFor computational efficiency, we’d want the array to contain elements all of the same type.\nNote that languages like R and Python distinguish types intended for math (e.g., numpy arrays, R matrices) from more general types (e.g., lists). This is not the case for Julia, where the key thing is the type(s) involved.\n\n\n\n\nMulti-dimensional arrays\n\nA = [1 2 3; 4 5 6; 7 8 9]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\nA\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\nA[2,2]\n\n5\n\nA[2,:]\n\n3-element Vector{Int64}:\n 4\n 5\n 6\n\n\nsize(A)\n\n(3, 3)\n\nsize(A, 2)\n\n3\n\n\n## Defined column-wise:\nA = [1:4  5:8  ones(Int64,4)]\n\n4×3 Matrix{Int64}:\n 1  5  1\n 2  6  1\n 3  7  1\n 4  8  1\n\n\n\n\nArrays vs. vectors\n\nones(5)\n\n5-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\nones(5, 1)\n\n5×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\nones(1, 5)\n\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\nones(5, 5)\n\n5×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\n\n## Outer product:\nones(5, 1) * ones(1, 5)\n\n5×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\nones(5, 1) .* ones(1, 5)\n\n5×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\nA bit of linear algebra\nWe do linear algebra directly on the core Array type.\n\nA = [1 2 3; 4 1 6; 7 8 1]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  1  6\n 7  8  1\n\nA * A\n\n3×3 Matrix{Int64}:\n 30  28  18\n 50  57  24\n 46  30  70\n\n\n\n\n\n\n\n\nExercise\n\n\n\nWhat do you expect to happen if you try to do matrix multiplication with a matrix with a mix of reals and integers? What would you expect if an element is a string?\n\n\nMuch more on linear algebra in a few weeks.\n\n\nMore on vectorization\n\nx = [\"spam\", 2.0, 5, [10, 20]]\n\n4-element Vector{Any}:\n  \"spam\"\n 2.0\n 5\n  [10, 20]\n\nlength(x)\n\n4\n\nlength.(x)\n\n4-element Vector{Int64}:\n 4\n 1\n 1\n 2\n\nmap(length, x)\n\n4-element Vector{Int64}:\n 4\n 1\n 1\n 2\n\n\nx = [2.1, 3.1, 5.3, 7.9]\n\n4-element Vector{Float64}:\n 2.1\n 3.1\n 5.3\n 7.9\n\nx .+ 10\n\n4-element Vector{Float64}:\n 12.1\n 13.1\n 15.3\n 17.9\n\n\nx + x\n\n4-element Vector{Float64}:\n  4.2\n  6.2\n 10.6\n 15.8\n\n\nx .&gt; 5.0\n\n4-element BitVector:\n 0\n 0\n 1\n 1\n\nx .== 3.1\n\n4-element BitVector:\n 0\n 1\n 0\n 0\n\n\n\n\nReduction\n\nA = rand(4, 5)\n\n4×5 Matrix{Float64}:\n 0.0809555  0.450622   0.588191  0.313559  0.17773\n 0.690901   0.0684225  0.156407  0.64965   0.463891\n 0.735239   0.151973   0.476314  0.516865  0.42032\n 0.974225   0.998125   0.577877  0.621698  0.721208\n\nsum(A)\n\n9.834171748382039\n\nsum(A, dims = 1)  # 2D array result\n\n1×5 Matrix{Float64}:\n 2.48132  1.66914  1.79879  2.10177  1.78315\n\nsum(A, dims = 1)[:]  # 1D array result\n\n5-element Vector{Float64}:\n 2.481320061077832\n 1.6691417775102653\n 1.798789605439191\n 2.101771208781533\n 1.7831490955732172\n\n\nsum(A, dims = 2)\n\n4×1 Matrix{Float64}:\n 1.6110569486436717\n 2.0292718524280793\n 2.3007105603339717\n 3.8931323869763155\n\n\n\n\nList comprehension (comprehension syntax)\nSimilar to Python.\n\ny = [1.0, 2.0, 2.5]\n\n3-element Vector{Float64}:\n 1.0\n 2.0\n 2.5\n\nysq = [ w^2 for w in y ]\n\n3-element Vector{Float64}:\n 1.0\n 4.0\n 6.25\n\nxsqu = [ x^2 for x = 1:5 ]\n\n5-element Vector{Int64}:\n  1\n  4\n  9\n 16\n 25\n\n\nxsqu_even = [ x^2 for x = 1:5 if iseven(x)]\n\n2-element Vector{Int64}:\n  4\n 16\n\n\nnorm2 = [ x^2 + y^2 for x = 1:5, y = 1:5 ]\n\n5×5 Matrix{Int64}:\n  2   5  10  17  26\n  5   8  13  20  29\n 10  13  18  25  34\n 17  20  25  32  41\n 26  29  34  41  50\n\n\nA nice terse shorthand but can be hard to read.\n(Some people love it and some people hate it.)",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#dictionaries-tuples-and-structs",
    "href": "notes/notes1.html#dictionaries-tuples-and-structs",
    "title": "Notes 1: Introduction",
    "section": "Dictionaries, tuples, and structs",
    "text": "Dictionaries, tuples, and structs\n\nDictionaries\nKey-value pairs like Python dictionaries (and somewhat like named R lists).\n\nx = Dict(\"test\" =&gt; 3, \"tmp\" =&gt; [2.1, 3.5], 7 =&gt; \"weird\")\n\nDict{Any, Any} with 3 entries:\n  7      =&gt; \"weird\"\n  \"test\" =&gt; 3\n  \"tmp\"  =&gt; [2.1, 3.5]\n\nx[\"tmp\"][2]\n\n3.5\n\nx[7]\n\n\"weird\"\n\nx[\"newkey\"] = 'a'\n\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\nkeys(x)\n\nKeySet for a Dict{Any, Any} with 4 entries. Keys:\n  7\n  \"test\"\n  \"tmp\"\n  \"newkey\"\n\n\n\nx[\"hello\"]\n\nERROR: KeyError: key \"hello\" not found\n\nget(x, \"hello\", 0)\n\n0\n\n\nNote that the keys don’t have to be strings! This could be good for caching/memoizing/lookup:\n\nx = Dict([\"foo\", \"bar\"] =&gt; 3, \"tmp\" =&gt; [2.1, 3.5], 7 =&gt; \"weird\")\n\nDict{Any, Any} with 3 entries:\n  7              =&gt; \"weird\"\n  [\"foo\", \"bar\"] =&gt; 3\n  \"tmp\"          =&gt; [2.1, 3.5]\n\nx[[\"foo\", \"bar\"]]\n\n3\n\nind = 7\n\n7\n\nx[ind]\n\n\"weird\"\n\ntypeof(ind)\n\nInt64\n\n\nIt would be interesting to know how it’s implemented that arbitrary objects can be keys. Perhaps using hashing?\nWhat do you think will happen here?\n\nind = Int32(7)  # What do you expect?\nx[ind]\nind = 7.0       # What do you expect?\nx[ind]\n\n\n\nTuples\nTuples are are similar to 1-dimensional arrays but they are immutable (they can’t be modified) and can have named elements.\n\nx = (3, 5, \"hello\")\n\n(3, 5, \"hello\")\n\nx[2]\n\n5\n\n\n\nx[2] = 7\n\nERROR: MethodError: no method matching setindex!(::Tuple{Int64, Int64, String}, ::Int64, ::Int64)\n\nx = 3\n\n3\n\ny = 9\n\n9\n\ny,x = x,y\n\n(3, 9)\n\n\n# Named tuple:\nx = (a=3, b=5, other=\"hello\")\n\n(a = 3, b = 5, other = \"hello\")\n\nx.b\n\n5\n\n\n\n\n\n\n\n\nFunctions with ! in their names\n\n\n\nWhat’s the deal with the “!” in setindex? We’ll see this more shortly, but functions that modify their inputs should have their name end in “!”.\n\n\nWhat do you think will happen here?\n\nx = (a=3, b=5, other=\"hello\", b=\"foo\")\nx.b\n\nTuples come in handy for providing flexibility in function inputs and outputs, as seen next.\n\n\nTuples and functions\nHere we create a function that can take an arbitrary number of inputs.\n\nfunction flexsum(args...)\n   println(\"The first value is $(args[1]).\")\n   x = args[1]*2\n   return sum(args)\nend\n\nflexsum (generic function with 1 method)\n\n\nflexsum(5, 7, 9)\n\nThe first value is 5.\n\n\n21\n\n\nHere’s how to call a function that takes multiple inputs, but pass as a tuple:\n\nfunction mydiv(x, y)\n   return x / y\nend\n\nmydiv (generic function with 1 method)\n\n\nvals = [3,5]\n\n2-element Vector{Int64}:\n 3\n 5\n\nmydiv(vals...)\n\n0.6\n\n\nWe use tuples to have a function return multiple values.\n\nfunction flexsum(args...)\n   println(\"The first value is $(args[1]).\")\n   x = args[1]*2\n   return args, x, sum(args)\nend\n\nflexsum (generic function with 1 method)\n\n\nflexsum(5, 7, 9)\n\nThe first value is 5.\n\n\n((5, 7, 9), 10, 21)\n\n\n\n\nStructs\nA struct is a “composite type”, a collection of named fields, useful for holding information with a particular structure.\n\nstruct Person\n  name\n  age\n  occupation\nend\n\nlincoln = Person(\"Abraham Lincoln\", 203, \"politician\")\n\nPerson(\"Abraham Lincoln\", 203, \"politician\")\n\nlincoln.age\n\n203\n\n\nWe’ll see much more on structs next week when we talk more about using types for robust code.\nLet’s discuss how these are similar to and different from objects in object-oriented languages like Python, Java, and C++.",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#loops",
    "href": "notes/notes1.html#loops",
    "title": "Notes 1: Introduction",
    "section": "Loops",
    "text": "Loops\nWe’ll illustrate for loop syntax by using Monte Carlo simulation to estimate \\(\\pi\\) by generating points in a square and then finding the number that are inside the unit circle.\n\nnumThrows = 1000;\nin_circle = 0;\n\n# Run Monte Carlo simulation\nfor _ in 1:numThrows\n  # Generate random points on 2x2 square.\n  xPos = rand() * 2 - 1.0  # Equivalent to random.uniform(-1.0, 1.0)\n  yPos = rand() * 2 - 1.0\n\n  # Is point inside unit circle?\n  if sqrt(xPos^2 + yPos^2) &lt;= 1.0  # Equivalent to math.hypot()\n    in_circle += 1\n  end\nend\n\n# Estimate PI\npi_estimate = 4 * in_circle / numThrows\n\nIf you were using R or Python, what would the value of xPos be at the end of the loop execution?\n\nxPos\n\nERROR: UndefVarError: `xPos` not defined\nIn Julia, variables defined in the loop are local variables accessible only in the scope of the loop (more on scoping soon). This avoids clutter in the global scope.\n\n\n\n\n\n\nExercise\n\n\n\nI used different naming conventions for my variables (numThrows and in_circle). Look online to see what the recommended style is.\n\n\nWe can iterate over elements of an object like this:\n\nfor i in eachindex(x)\n  println(i)\nend\n\na\nb\nother",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  },
  {
    "objectID": "notes/notes1.html#string-processing-and-regular-expressions",
    "href": "notes/notes1.html#string-processing-and-regular-expressions",
    "title": "Notes 1: Introduction",
    "section": "String processing and regular expressions",
    "text": "String processing and regular expressions\n\nx = \"The cat in the hat.\"\n\n\"The cat in the hat.\"\n\nreplace(x, \"at\"=&gt;\"\")\n\n\"The c in the h.\"\n\n\nx = \"We found 999 red balloons.\"\n\n\"We found 999 red balloons.\"\n\nreplace(x, r\"[0-9]+\"=&gt;\"some\")  # Regular expression.\n\n\"We found some red balloons.\"\n\n\n'a' ∈ \"banana\"\n\ntrue\n\n\n\nx = \"We found 99 red balloons.\"\n\n\"We found 99 red balloons.\"\n\nm = match(r\"[0-9]+ ([a-z]+)\", x)\n\nRegexMatch(\"99 red\", 1=\"red\")\n\nm.match\n\n\"99 red\"\n\nm.captures\n\n1-element Vector{Union{Nothing, SubString{String}}}:\n \"red\"\n\nm.offset\n\n10",
    "crumbs": [
      "Course Notes",
      "Notes 1: Introduction"
    ]
  }
]