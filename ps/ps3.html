<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Problem Set 3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e3c2a318547996e22cb8eadf618fd4f6.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../assets/styles.css">
<link rel="stylesheet" href="../styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ps3.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Problem Set 3</h1>
<p class="subtitle lead">Due Thursday Mar.&nbsp;6, 12:30 pm</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="comments" class="level2">
<h2 class="anchored" data-anchor-id="comments">Comments</h2>
<ul>
<li>I haven’t fully worked these problems myself, so if you run into any strange issues, please post on Ed as there could be mistakes/oversights on my part.</li>
<li>Please submit as a PDF to Gradescope.</li>
<li>Please generate the PDF using Quarto. Feel free to work in a Jupyter notebook and then convert to Quarto before rendering to PDF. Other formats that look professional and are designed for working with code and math notation may also be fine - just check with me via a public post on Ed first.</li>
<li>Remember to note at the start of your document the names of any other students that you worked with on the problem set (or indicating you didn’t work with anyone if that was the case) and then indicate in the text or in code comments any specific ideas or code you borrowed from another student or any online reference (including ChatGPT or the like).</li>
<li>In general, your solution should not just be code - you should have text describing how you approached the problem and what decisions/conclusions you made, though for simple problems, this can be quite short. Your code should have comments indicating what each function or block of code does, and for any lines of code or code constructs that may be hard to understand, a comment indicating what that code does.</li>
<li>You do not need to (and should not) show exhaustive output, but in general you should show short examples of what your code does to demonstrate its functionality. The output should be produced as a result of the code chunks being run during the rendering process, not by copy-pasting of output from running the code separately (and definitely not as screenshots).</li>
<li>I do not recommend writing initial answers using a ChatBot, as I think you are likely to fool yourself in terms of how much you are learning about Julia and programming concepts/skills more generally. But it’s up to you to decide how heavily to rely on a ChatBot. And refining your initial answers using a ChatBot seems like a good strategy. Using your own knowledge and information online to check the results of a ChatBot and using a ChatBot to check your own coding can both be important/useful.</li>
</ul>
</section>
<section id="problems" class="level2">
<h2 class="anchored" data-anchor-id="problems">Problems</h2>
<p>[UNDER CONSTRUCTION]</p>
</section>
<section id="problem-1" class="level2">
<h2 class="anchored" data-anchor-id="problem-1">Problem 1</h2>
<p>Gaussian processes provide a distribution over functions, allowing us to simulate random time series and images, amongst other things. We’ll focus on using Gaussian processes in one dimension.</p>
<p>Consider a set of values <span class="math inline">\({x_1,\ldots,x_n} \in \Re\)</span>. We will simulate <span class="math inline">\(y \sim MVN(\mu 1, \Sigma)\)</span>, where <span class="math inline">\(\mu\)</span> is (for simplicity) a scalar mean and <span class="math inline">\(1\)</span> is a vector of ones. The covariance matrix, <span class="math inline">\(\Sigma\)</span> is constructed as <span class="math inline">\(\Sigma_{i,j} = f(x_i, x_j)\)</span> for some positive definite covariance function, <span class="math inline">\(f\)</span>. Some examples are the exponential covariance, <span class="math inline">\(f(x_i,x_j) = \sigma^2 \exp(-d_{i,j}/rho)\)</span> for <span class="math inline">\(d_{i,j}=|x_i-x_j}\)</span>and the squared exponential <span class="math inline">\(f(x_i,x_j) = \sigma^2 \exp(-d_{i,j}^2^2/rho^2)\)</span>. Note that in both cases these are simple stationary covariance functions that are functions of the distance between the two points (more complicated covariance functions are possible). To simulate a random function (in the one-d case, you can think of this as a random time series), we compute</p>
<p><span class="math display">\[ \mu 1 + L z \]</span> where <span class="math inline">\(L\)</span> is the lower-triangular Cholesky decomposition of <span class="math inline">\(\Sigma\)</span> and <span class="math inline">\(z\)</span> is a vector of <span class="math inline">\(n\)</span> numbers simulated independently from a standard normal.</p>
<section id="problem-1a" class="level3">
<h3 class="anchored" data-anchor-id="problem-1a">Problem 1a</h3>
<ul>
<li>Use structs and functions with type annotation to implement this in Julia. Make sure to continue to cache information effectively for cases where a user wants to simulate multiple time series. We’ll discuss linear algebra further in Weeks 5 or 6. Include logging and exceptions as you did in PS2.</li>
</ul>
<p>An object-oriented implementation is available in Python here. https://stat243.berkeley.edu/fall-2024/units/unit5-programming.html#classes-in-python</p>
<p>Distances.jl has a Euclidean() distance function.</p>
</section>
<section id="problem-1b" class="level3">
<h3 class="anchored" data-anchor-id="problem-1b">Problem 1b</h3>
<p>Take this grid: $x = 0:0.1:1. Use Float64 and Float16 representations to compute <span class="math inline">\(\Sigma\)</span> and its Cholesky. See what happens with the coarser and finer grids.</p>
<p>x = 0:0.1:1 xFine = 0:0.01:1</p>
<p>dists64 = pairwise(Euclidean(), x); dists16 = Float16.(dists64); SigmaExp = exp.(.- dists64 ./ rho); SigmaExp16 = exp.(.- dists16 ./ rho); SigmaSquExp = exp.(.- dists64 .^2 ./ rho^2); SigmaSquExp16 = exp.(.- dists16 .^2 ./rho^2);</p>
<p>using LinearAlgebra LExp = cholesky(SigmaExp).L LExp16 = cholesky(SigmaExp16).L LSquExp = cholesky(SigmaSquExp).L LSquExp16 = cholesky(SigmaSquExp16).L # fails with 0.1</p>
<p>One (slightly awkward) workaround is to add a small epsilon to the diagonal of <span class="math inline">\(\Sigma\)</span> for non-numerically positive definite cases.</p>
<p>Plot a random time series with the finer grid and notice the difference in smoothness between the exponential and squared exponential cases.</p>
</section>
<section id="problem-1c" class="level3">
<h3 class="anchored" data-anchor-id="problem-1c">Problem 1c</h3>
<ul>
<li>Allow your code to use GPUs if available on the system (but fall back to the CPU if no GPU is available). Benchmark your code on an SCF GPU (or your own if you happen to have one or have access to one), making sure to report which type of GPU you used for your work. In your time comparisons, also compare to using multiple CPU cores via the threaded BLAS.</li>
</ul>
</section>
<section id="problem-1d" class="level3">
<h3 class="anchored" data-anchor-id="problem-1d">Problem 1d</h3>
<ul>
<li>Suppose your users want to generate many time series at once (e.g., for a simulation study). So the output should be a n x m where m is the number of simulations. Use threaded or multi-process parallelization (your choice) to generate the time series in parallel, using the same underlying cholesky decomposition. [investigate parallel RNG and whether they should just use different seed]</li>
</ul>
</section>
</section>
<section id="problem-2" class="level2">
<h2 class="anchored" data-anchor-id="problem-2">Problem 2</h2>
</section>
<section id="problem-2a" class="level2">
<h2 class="anchored" data-anchor-id="problem-2a">Problem 2a</h2>
<p>Write a kernel using Julia that computes a kernel density estimate in two dimensions using a normal density with bandwidth $h = <span class="math inline">\(\sigma\)</span> for some input dataset with <span class="math inline">\(n\)</span> data points. Your code should compute the KDE on a grid of points, for <span class="math inline">\(m\)</span> points, with each evaluation point handled in a separate thread. This means that each thread will access the full dataset (more on this in part (c).</p>
<p>You’ll presumably want a value of h somewhere between, say, 10 km and 300 km.</p>
<p>Apply your code to the data on the location of wildfires in the US (fire.csv), which contains information on the location, year, and size of fires in the US from the federal government’s wildfire database (obtained from kaggle here: https://www.kaggle.com/code/behroozsohrabi/us-wildfires-dataset-exploration) and then modified to remove various columns and project to an Albers equal area projection in meters, so that we can directly work with Euclidean distances.</p>
<p>https://www.fs.usda.gov/rds/archive/catalog/RDS-2013-0009.6</p>
<p>paciorek@smeagol:/scratch/users/paciorek/fire_data</p>
<p>Feel free to subset to a portion of the US of interest to you. And feel free to choose a square region and implement your code assuming a regular square grid of evaluation points to keep things simpler. There are 2.3 million fires in the dataset, most of them quite small.</p>
</section>
<section id="problem-2b" class="level2">
<h2 class="anchored" data-anchor-id="problem-2b">Problem 2b</h2>
<p>Now consider using 10-fold cross-validation to find the best value of <span class="math inline">\(h\)</span> from a (small-ish) grid of potential values (possibly equally-spaced on the log scale rather than the original scale), evaluating the log of the kernel density estimate on the test set. First time this by calling your kernel from part (a) 10 times for each value of <span class="math inline">\(h\)</span>.</p>
<p>Next, include the calculation of the density for each value of <span class="math inline">\(h\)</span> in a loop within the kernel. Call your kernel 10 times. Compare the timing when you avoid having to re-access the data for each value of $h.</p>
<p>(Note that one could go further by embedding the cross-validation in the kernel too…)</p>
</section>
<section id="problem-2c." class="level2">
<h2 class="anchored" data-anchor-id="problem-2c.">Problem 2c.</h2>
<p>Now consider using the shared memory amongst the threads in a block via <code>CuStaticSharedArray</code>. Load the data in blocks of size equal to the number of threads into the shared array in parallel using the threads in the block. Then use your code from earlier to calculate the density for the block of data for each evaluation point in a thread. Finally wrap this by looping over all the data blocks.</p>
<p>Compare the speed here with Problem 2a.</p>
<p>Note that rather than having each thread handle a single evaluation point on the grid, one could have each thread handle a single data point. This would reduce memory access, but there would then need to be a shared reduction operation, which involves <em>atomic</em> calls. Ideally one would first do the partial reduction across the data points within each block in shared memory.</p>
<section id="section" class="level20">
<p class="heading"></p>
<p>Have each thread</p>
<p>have them create 2-d grid KDE in various dimensions; on cpu program cross-vali? layer in cross-validation (perhaps on a grid) - how does timing scale with number of cv points? is this better than calling the kernel p times? extend to load chunk of data into shared memory within a block so that not all threads are accessing global memory at once</p>
<p>CuStaticSharedArray</p>
<p>could have each thread handle a data point; then need shared reduction operation which involves atomic calls. Ideally one would first do the partial reduction within each block in shared memory.</p>
<p>can one call another fxn in the kernel? yes</p>
<p>function kde_kernel_shared!(densities, eval_points, data, n_eval, n_data, bandwidth) # Get thread and block indices tidx = threadIdx().x bidx = blockIdx().x</p>
<pre><code># Calculate global index for evaluation point
eval_idx = tidx + (bidx - 1) * blockDim().x

# Shared memory for data points
# Each block loads a subset of data points at a time
shared_data = @cuDynamicSharedMem(Float32, blockDim().x)

# Initialize density accumulator for this evaluation point
density = 0.0f0

# Only continue if this thread has a valid evaluation point
if eval_idx &lt;= n_eval
    x = eval_points[eval_idx]
    
    # Process data in tiles
    for tile_start = 1:blockDim().x:n_data
        # Number of points in this tile
        tile_size = min(blockDim().x, n_data - tile_start + 1)
        
        # Load data into shared memory
        if tidx &lt;= tile_size
            shared_data[tidx] = data[tile_start + tidx - 1]
        end
        
        # Wait for all threads to finish loading
        sync_threads()
        
        # Process all points in this tile
        for i = 1:tile_size
            u = (x - shared_data[i]) / bandwidth
            density += exp(-0.5f0 * u * u)
        end
        
        # Wait for all threads to finish using shared memory
        sync_threads()
    end
    
    # Normalize and store final result
    densities[eval_idx] = density / (n_data * bandwidth * sqrt(2.0f0 * π))
end

return nothing</code></pre>
<p>end</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/berkeley-stat244\.github\.io\/spring-2025");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>